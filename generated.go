// Package vesselapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package vesselapi

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ErrorCode.
const (
	ErrorCodeDatabaseError      ErrorCode = "database_error"
	ErrorCodeInternalError      ErrorCode = "internal_error"
	ErrorCodeInvalidAPIKey      ErrorCode = "invalid_api_key"
	ErrorCodeInvalidCoordinates ErrorCode = "invalid_coordinates"
	ErrorCodeInvalidIMO         ErrorCode = "invalid_imo"
	ErrorCodeInvalidMMSI        ErrorCode = "invalid_mmsi"
	ErrorCodeInvalidParameter   ErrorCode = "invalid_parameter"
	ErrorCodeInvalidTimeRange   ErrorCode = "invalid_time_range"
	ErrorCodeMissingParameter   ErrorCode = "missing_parameter"
	ErrorCodeRateLimitExceeded  ErrorCode = "rate_limit_exceeded"
	ErrorCodeResourceMissing    ErrorCode = "resource_missing"
	ErrorCodeServiceUnavailable ErrorCode = "service_unavailable"
)

// Defines values for ErrorType.
const (
	ErrorTypeAPIError            ErrorType = "api_error"
	ErrorTypeAuthenticationError ErrorType = "authentication_error"
	ErrorTypeInvalidRequest      ErrorType = "invalid_request_error"
	ErrorTypeNotFoundError       ErrorType = "not_found_error"
	ErrorTypeRateLimitError      ErrorType = "rate_limit_error"
	ErrorTypeServiceUnavailable  ErrorType = "service_unavailable_error"
)

// Defines values for GetPorteventsVesselIdParamsFilterIdType.
const (
	GetPorteventsVesselIdParamsFilterIdTypeImo  GetPorteventsVesselIdParamsFilterIdType = "imo"
	GetPorteventsVesselIdParamsFilterIdTypeMmsi GetPorteventsVesselIdParamsFilterIdType = "mmsi"
)

// Defines values for GetPorteventsVesselIdParamsFilterEventType.
const (
	All       GetPorteventsVesselIdParamsFilterEventType = "all"
	Arrival   GetPorteventsVesselIdParamsFilterEventType = "arrival"
	Departure GetPorteventsVesselIdParamsFilterEventType = "departure"
)

// Defines values for GetPorteventsVesselIdParamsFilterSortOrder.
const (
	Asc  GetPorteventsVesselIdParamsFilterSortOrder = "asc"
	Desc GetPorteventsVesselIdParamsFilterSortOrder = "desc"
)

// Defines values for GetPorteventsVesselIdLastParamsFilterIdType.
const (
	GetPorteventsVesselIdLastParamsFilterIdTypeImo  GetPorteventsVesselIdLastParamsFilterIdType = "imo"
	GetPorteventsVesselIdLastParamsFilterIdTypeMmsi GetPorteventsVesselIdLastParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdParamsFilterIdType.
const (
	GetVesselIdParamsFilterIdTypeImo  GetVesselIdParamsFilterIdType = "imo"
	GetVesselIdParamsFilterIdTypeMmsi GetVesselIdParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdCasualtiesParamsFilterIdType.
const (
	GetVesselIdCasualtiesParamsFilterIdTypeImo  GetVesselIdCasualtiesParamsFilterIdType = "imo"
	GetVesselIdCasualtiesParamsFilterIdTypeMmsi GetVesselIdCasualtiesParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdClassificationParamsFilterIdType.
const (
	GetVesselIdClassificationParamsFilterIdTypeImo  GetVesselIdClassificationParamsFilterIdType = "imo"
	GetVesselIdClassificationParamsFilterIdTypeMmsi GetVesselIdClassificationParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdEmissionsParamsFilterIdType.
const (
	GetVesselIdEmissionsParamsFilterIdTypeImo  GetVesselIdEmissionsParamsFilterIdType = "imo"
	GetVesselIdEmissionsParamsFilterIdTypeMmsi GetVesselIdEmissionsParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdEtaParamsFilterIdType.
const (
	GetVesselIdEtaParamsFilterIdTypeImo  GetVesselIdEtaParamsFilterIdType = "imo"
	GetVesselIdEtaParamsFilterIdTypeMmsi GetVesselIdEtaParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdInspectionsParamsFilterIdType.
const (
	GetVesselIdInspectionsParamsFilterIdTypeImo  GetVesselIdInspectionsParamsFilterIdType = "imo"
	GetVesselIdInspectionsParamsFilterIdTypeMmsi GetVesselIdInspectionsParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdInspectionsDetailIdParamsFilterIdType.
const (
	GetVesselIdInspectionsDetailIdParamsFilterIdTypeImo  GetVesselIdInspectionsDetailIdParamsFilterIdType = "imo"
	GetVesselIdInspectionsDetailIdParamsFilterIdTypeMmsi GetVesselIdInspectionsDetailIdParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdOwnershipParamsFilterIdType.
const (
	GetVesselIdOwnershipParamsFilterIdTypeImo  GetVesselIdOwnershipParamsFilterIdType = "imo"
	GetVesselIdOwnershipParamsFilterIdTypeMmsi GetVesselIdOwnershipParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselIdPositionParamsFilterIdType.
const (
	GetVesselIdPositionParamsFilterIdTypeImo  GetVesselIdPositionParamsFilterIdType = "imo"
	GetVesselIdPositionParamsFilterIdTypeMmsi GetVesselIdPositionParamsFilterIdType = "mmsi"
)

// Defines values for GetVesselsPositionsParamsFilterIdType.
const (
	GetVesselsPositionsParamsFilterIdTypeImo  GetVesselsPositionsParamsFilterIdType = "imo"
	GetVesselsPositionsParamsFilterIdTypeMmsi GetVesselsPositionsParamsFilterIdType = "mmsi"
)

// AuthenticationErrorDetail Detailed authentication error information
type AuthenticationErrorDetail struct {
	// Code is a short string identifier for this error for programmatic handling
	Code *ErrorCode `json:"code,omitempty"`

	// Message is a human-readable message providing more details about the error
	Message *string `json:"message,omitempty"`

	// Type categorizes the error (always "authentication_error" for 401s)
	Type *ErrorType `json:"type,omitempty"`
}

// AuthenticationErrorResponse Response returned when authentication fails (HTTP 401)
type AuthenticationErrorResponse struct {
	// Error Detailed authentication error information
	Error *AuthenticationErrorDetail `json:"error,omitempty"`
}

// BadRequestErrorDetail Detailed bad request error information
type BadRequestErrorDetail struct {
	// Code is a short string identifier for this error for programmatic handling
	Code *ErrorCode `json:"code,omitempty"`

	// DocUrl DocURL is a link to documentation for more information
	DocUrl *string `json:"doc_url,omitempty"`

	// Message is a human-readable message providing more details about the error
	Message *string `json:"message,omitempty"`

	// Param identifies the parameter that caused the error (if applicable)
	Param *string `json:"param,omitempty"`

	// Type categorizes the error (e.g., "invalid_request_error")
	Type *ErrorType `json:"type,omitempty"`
}

// BadRequestErrorResponse Response returned for invalid requests (HTTP 400)
type BadRequestErrorResponse struct {
	// Error Detailed bad request error information
	Error *BadRequestErrorDetail `json:"error,omitempty"`
}

// ClassificationResponse Response containing vessel classification data
type ClassificationResponse struct {
	// Classification Vessel classification data including identification, certificates, surveys, and technical specifications
	Classification *ClassificationVessel `json:"classification,omitempty"`
}

// ClassificationVessel Vessel classification data including identification, certificates, surveys, and technical specifications
type ClassificationVessel struct {
	// Certificates List of vessel certificates
	Certificates *[]GithubComVesselapiCommonVesselDataContractsTypesClassificationCertificate `json:"certificates,omitempty"`

	// Classification Classification society notation and status information
	Classification *GithubComVesselapiCommonVesselDataContractsTypesClassificationInfo `json:"classification,omitempty"`

	// CollectedAt UTC timestamp when data was collected
	CollectedAt *string `json:"collectedAt,omitempty"`

	// Conditions Conditions of class imposed on the vessel
	Conditions *[]GithubComVesselapiCommonVesselDataContractsTypesClassificationCondition `json:"conditions,omitempty"`

	// Dimensions Vessel dimensional measurements from classification records
	Dimensions *GithubComVesselapiCommonVesselDataContractsTypesClassificationDimensions `json:"dimensions,omitempty"`

	// Hull Vessel hull construction details
	Hull *GithubComVesselapiCommonVesselDataContractsTypesClassificationHull `json:"hull,omitempty"`

	// Identification Vessel identification details from classification society records
	Identification *GithubComVesselapiCommonVesselDataContractsTypesClassificationIdentification `json:"identification,omitempty"`

	// Imo Metadata (set by collector, not from API)
	Imo *int `json:"imo,omitempty"`

	// Machinery Vessel machinery and propulsion details
	Machinery *GithubComVesselapiCommonVesselDataContractsTypesClassificationMachinery `json:"machinery,omitempty"`

	// Owner Vessel owner and management company details from classification records
	Owner *GithubComVesselapiCommonVesselDataContractsTypesClassificationOwner `json:"owner,omitempty"`

	// Surveys Survey records from classification society
	Surveys *[]GithubComVesselapiCommonVesselDataContractsTypesClassificationSurvey `json:"surveys,omitempty"`

	// Yard Shipyard and construction details from classification records
	Yard *GithubComVesselapiCommonVesselDataContractsTypesClassificationYard `json:"yard,omitempty"`
}

// DGPSStation Differential GPS (DGPS) correction signal broadcast station
type DGPSStation struct {
	// AidType Type of navigational aid
	AidType *string `json:"aid_type,omitempty"`

	// DeleteFlag Deletion status flag
	DeleteFlag *string `json:"delete_flag,omitempty"`

	// FeatureNumber NGA feature number identifier
	FeatureNumber *int `json:"feature_number,omitempty"`

	// Frequency Broadcast frequency in kHz
	Frequency *float32 `json:"frequency,omitempty"`

	// GeopoliticalHeading Country or major geographic area
	GeopoliticalHeading *string `json:"geopolitical_heading,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Name Station name
	Name *string `json:"name,omitempty"`

	// NoticeNumber Notice to Mariners number
	NoticeNumber *int `json:"notice_number,omitempty"`

	// NoticeWeek Week of the notice
	NoticeWeek *string `json:"notice_week,omitempty"`

	// NoticeYear Year of the notice
	NoticeYear *string `json:"notice_year,omitempty"`

	// Position Human-readable position description
	Position *string `json:"position,omitempty"`

	// PostNote Notes appearing after the main entry
	PostNote *string `json:"post_note,omitempty"`

	// PrecedingNote Notes appearing before the main entry
	PrecedingNote *string `json:"preceding_note,omitempty"`

	// Range Signal range in nautical miles
	Range *int `json:"range,omitempty"`

	// RegionHeading Regional geographic subdivision
	RegionHeading *string `json:"region_heading,omitempty"`

	// Remarks Additional remarks about the station
	Remarks *string `json:"remarks,omitempty"`

	// RemoveFromList Flag indicating if entry should be removed
	RemoveFromList *string `json:"remove_from_list,omitempty"`

	// StationId StationID Station identifier code
	StationId *string `json:"station_id,omitempty"`

	// TransferRate Data transfer rate in bits per second
	TransferRate *int `json:"transfer_rate,omitempty"`

	// VolumeNumber NGA publication volume number
	VolumeNumber *string `json:"volume_number,omitempty"`
}

// DGPSStationsWithinLocationResponse Response containing DGPS stations within location data
type DGPSStationsWithinLocationResponse struct {
	// DgpsStations List of DGPS stations within the specified area
	DgpsStations *[]DGPSStation `json:"dgpsStations,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// ErrorCode Machine-readable error code for programmatic handling
type ErrorCode string

// ErrorType High-level error category classification
type ErrorType string

// FindDGPSStationsResponse Response containing dgps station data
type FindDGPSStationsResponse struct {
	// DgpsStations List of matching DGPS stations
	DgpsStations *[]DGPSStation `json:"dgpsStations,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// FindLightAidsResponse Response containing light aid data
type FindLightAidsResponse struct {
	// LightAids List of matching light aids
	LightAids *[]LightAid `json:"lightAids,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// FindMODUsResponse Response containing MODU search results
type FindMODUsResponse struct {
	// Modus List of matching MODUs
	Modus *[]MODU `json:"modus,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// FindPortsResponse Response containing port data
type FindPortsResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// Ports List of matching ports
	Ports *[]Port `json:"ports,omitempty"`
}

// FindRadioBeaconsResponse Response containing radio beacon data
type FindRadioBeaconsResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// RadioBeacons List of matching radio beacons
	RadioBeacons *[]RadioBeacon `json:"radioBeacons,omitempty"`
}

// FindVesselsResponse Response containing vessel search results
type FindVesselsResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// Vessels List of matching vessels
	Vessels *[]Vessel `json:"vessels,omitempty"`
}

// InternalServerErrorDetail Detailed internal server error information
type InternalServerErrorDetail struct {
	// Code is a short string identifier for this error for programmatic handling
	Code *ErrorCode `json:"code,omitempty"`

	// ErrorId ErrorID is a unique identifier for tracking this error (always present for 500 errors)
	ErrorId *string `json:"error_id,omitempty"`

	// Message is a human-readable message providing more details about the error
	Message *string `json:"message,omitempty"`

	// Timestamp when the error occurred (ISO 8601 format)
	Timestamp *string `json:"timestamp,omitempty"`

	// Type categorizes the error (always "api_error" for 500s)
	Type *ErrorType `json:"type,omitempty"`
}

// InternalServerErrorResponse Response returned for internal server errors (HTTP 500)
type InternalServerErrorResponse struct {
	// Error Detailed internal server error information
	Error *InternalServerErrorDetail `json:"error,omitempty"`
}

// LightAid Navigational light aid including lighthouses, buoys, and beacons
type LightAid struct {
	// AidType Type of navigational aid (Light, Buoy, Beacon, etc.)
	AidType *string `json:"aid_type,omitempty"`

	// Characteristic Light flash pattern description (e.g., Fl W 7.5s)
	Characteristic *string `json:"characteristic,omitempty"`

	// CharacteristicNumber Light characteristic code number
	CharacteristicNumber *int `json:"characteristic_number,omitempty"`

	// DeleteFlag Deletion status flag
	DeleteFlag *string `json:"delete_flag,omitempty"`

	// FeatureNumber NGA feature number identifier
	FeatureNumber *string `json:"feature_number,omitempty"`

	// GeopoliticalHeading Country or major geographic area
	GeopoliticalHeading *string `json:"geopolitical_heading,omitempty"`

	// HeightFeetMeters Height of light above water in feet and meters
	HeightFeetMeters *string `json:"height_feet_meters,omitempty"`

	// LocalHeading Local area description
	LocalHeading *string `json:"local_heading,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Name Name of the light aid
	Name *string `json:"name,omitempty"`

	// NoticeNumber Notice to Mariners number
	NoticeNumber *int `json:"notice_number,omitempty"`

	// NoticeWeek Week of the notice
	NoticeWeek *string `json:"notice_week,omitempty"`

	// NoticeYear Year of the notice
	NoticeYear *string `json:"notice_year,omitempty"`

	// Position Human-readable position description
	Position *string `json:"position,omitempty"`

	// PostNote Notes appearing after the main entry
	PostNote *string `json:"post_note,omitempty"`

	// PrecedingNote Notes appearing before the main entry
	PrecedingNote *string `json:"preceding_note,omitempty"`

	// Range Nominal range of light in nautical miles
	Range *string `json:"range,omitempty"`

	// RegionHeading Regional geographic subdivision
	RegionHeading *string `json:"region_heading,omitempty"`

	// Remarks Additional remarks about the light
	Remarks *string `json:"remarks,omitempty"`

	// RemoveFromList Flag indicating if entry should be removed
	RemoveFromList *string `json:"remove_from_list,omitempty"`

	// Structure Description of the physical structure
	Structure *string `json:"structure,omitempty"`

	// SubregionHeading Sub-regional geographic area
	SubregionHeading *string `json:"subregion_heading,omitempty"`

	// VolumeNumber NGA publication volume number
	VolumeNumber *string `json:"volume_number,omitempty"`
}

// LightAidsWithinLocationResponse Response containing light aids within location data
type LightAidsWithinLocationResponse struct {
	// LightAids List of light aids within the specified area
	LightAids *[]LightAid `json:"lightAids,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// MODU Mobile Offshore Drilling Unit (MODU) location and status information
type MODU struct {
	// Date Date of the position report (parsed from API string format YYYY-MM-DD)
	Date *string `json:"date,omitempty"`

	// Distance Distance from reference point in nautical miles
	Distance *float32 `json:"distance,omitempty"`

	// Latitude Geographic latitude in decimal degrees
	Latitude *float64 `json:"latitude,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Longitude Geographic longitude in decimal degrees
	Longitude *float64 `json:"longitude,omitempty"`

	// Name Name of the drilling unit
	Name *string `json:"name,omitempty"`

	// NavigationArea NAVAREA designation
	NavigationArea *string `json:"navigation_area,omitempty"`

	// Position Human-readable position description
	Position *string `json:"position,omitempty"`

	// Region NGA region code
	Region *int `json:"region,omitempty"`

	// RigStatus Current operational status of the rig
	RigStatus *string `json:"rig_status,omitempty"`

	// SpecialStatus Any special status or notes
	SpecialStatus *string `json:"special_status,omitempty"`

	// SubRegion NGA sub-region code
	SubRegion *int `json:"sub_region,omitempty"`
}

// MODUsWithinLocationResponse Response containing MODUs within location data
type MODUsWithinLocationResponse struct {
	// Modus List of MODUs within the specified area
	Modus *[]MODU `json:"modus,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// MarineCasualtiesResponse Response containing marine casualty data
type MarineCasualtiesResponse struct {
	// Casualties List of marine casualty records
	Casualties *[]MarineCasualty `json:"casualties,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// MarineCasualty Marine casualty occurrence record from the European Marine Casualty Information Platform
type MarineCasualty struct {
	// AtCoding Accident type taxonomy codes
	AtCoding *[]string `json:"atCoding,omitempty"`

	// CasualtyReportNr Casualty report reference number
	CasualtyReportNr *string `json:"casualtyReportNr,omitempty"`

	// CfCoding Contributory factor taxonomy codes
	CfCoding *[]string `json:"cfCoding,omitempty"`

	// CollectedAt Metadata (set by collector, not from API)
	CollectedAt *string `json:"collectedAt,omitempty"`

	// CompetentAuthority Competent maritime authorities involved
	CompetentAuthority *[]string `json:"competentAuthority,omitempty"`

	// DateOfOccurrence Event details
	DateOfOccurrence *string `json:"dateOfOccurrence,omitempty"`

	// Deviation Deviation event taxonomy codes
	Deviation *[]string `json:"deviation,omitempty"`

	// EventType Type of marine event classifications
	EventType *[]string `json:"eventType,omitempty"`

	// FinishedInvestigation Whether the investigation has been completed
	FinishedInvestigation *bool `json:"finishedInvestigation,omitempty"`

	// ImoNr IMO numbers of vessels involved
	ImoNr *[]string `json:"imoNr,omitempty"`

	// InterimReport Whether an interim report has been published
	InterimReport *bool `json:"interimReport,omitempty"`

	// InvestigatingState Investigation
	InvestigatingState *string `json:"investigatingState,omitempty"`

	// LivesLostTotal Consequences
	LivesLostTotal *string `json:"livesLostTotal,omitempty"`

	// NameOfShip Vessel info (arrays since multiple vessels can be involved)
	NameOfShip *[]string `json:"nameOfShip,omitempty"`

	// OccurrenceSeverity Severity classification of the occurrence
	OccurrenceSeverity *string `json:"occurrenceSeverity,omitempty"`

	// OccurrenceUuid External IDs
	OccurrenceUuid *string `json:"occurrenceUuid,omitempty"`

	// OccurrenceWithPersons Person-related event taxonomy codes
	OccurrenceWithPersons *[]string `json:"occurrenceWithPersons,omitempty"`

	// OccurrenceWithShips Taxonomy classifications
	OccurrenceWithShips *[]string `json:"occurrenceWithShips,omitempty"`

	// PeopleInjuredTotal Total number of people injured
	PeopleInjuredTotal *string `json:"peopleInjuredTotal,omitempty"`

	// Pollution Whether pollution resulted from the casualty
	Pollution *bool `json:"pollution,omitempty"`

	// ShipCraftType Ship/craft type classifications of involved vessels
	ShipCraftType *[]string `json:"shipCraftType,omitempty"`

	// SrCoding Safety recommendation taxonomy codes
	SrCoding *[]string `json:"srCoding,omitempty"`
}

// Navtex NAVTEX maritime safety information broadcast message
type Navtex struct {
	// IssuingOffice Office that issued the bulletin
	IssuingOffice *string `json:"issuing_office,omitempty"`

	// Label Message type label (e.g., navigational warning, weather forecast)
	Label *string `json:"label,omitempty"`

	// Lines Message content split into individual lines
	Lines *[]string `json:"lines,omitempty"`

	// MetareaCoordinator Country/organization coordinating the METAREA
	MetareaCoordinator *string `json:"metarea_coordinator,omitempty"`

	// MetareaId MetareaID METAREA (Maritime Area) numeric identifier
	MetareaId *string `json:"metarea_id,omitempty"`

	// MetareaName Human-readable name of the METAREA
	MetareaName *string `json:"metarea_name,omitempty"`

	// MetareaRegion Geographic region of the METAREA
	MetareaRegion *string `json:"metarea_region,omitempty"`

	// MetareaStations List of broadcast stations within the METAREA
	MetareaStations *[]GithubComVesselapiCommonVesselDataContractsTypesBroadcastStation `json:"metarea_stations,omitempty"`

	// RawContent Original unprocessed message content
	RawContent *string `json:"raw_content,omitempty"`

	// Timestamp UTC timestamp from the bulletin
	Timestamp *string `json:"timestamp,omitempty"`

	// WmoHeader World Meteorological Organization header code
	WmoHeader *string `json:"wmo_header,omitempty"`
}

// NavtexMessagesResponse Response containing NAVTEX message data
type NavtexMessagesResponse struct {
	// NavtexMessages List of NAVTEX messages
	NavtexMessages *[]Navtex `json:"navtexMessages,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// NotFoundErrorDetail Detailed not found error information
type NotFoundErrorDetail struct {
	// Code is a short string identifier for this error for programmatic handling
	Code *ErrorCode `json:"code,omitempty"`

	// Message is a human-readable message providing more details about the error
	Message *string `json:"message,omitempty"`

	// Type categorizes the error (always "not_found_error" for 404s)
	Type *ErrorType `json:"type,omitempty"`
}

// NotFoundErrorResponse Response returned when the requested resource is not found (HTTP 404)
type NotFoundErrorResponse struct {
	// Error Detailed not found error information
	Error *NotFoundErrorDetail `json:"error,omitempty"`
}

// Port Complete port information including facilities, services, and characteristics
type Port struct {
	// AnchorageDepth Depth at the anchorage area
	AnchorageDepth *float32 `json:"anchorage_depth,omitempty"`

	// AnchorageDepthUnit Unit for anchorage depth measurement
	AnchorageDepthUnit *string `json:"anchorage_depth_unit,omitempty"`

	// CargoHandlingDepth Depth at cargo handling berths
	CargoHandlingDepth *float32 `json:"cargo_handling_depth,omitempty"`

	// CargoHandlingDepthUnit Unit for cargo handling depth measurement
	CargoHandlingDepthUnit *string `json:"cargo_handling_depth_unit,omitempty"`

	// ChannelDepth Depth of the approach channel
	ChannelDepth *float32 `json:"channel_depth,omitempty"`

	// ChannelDepthUnit Unit for channel depth measurement
	ChannelDepthUnit *string `json:"channel_depth_unit,omitempty"`

	// Country Country information for the port
	Country *GithubComVesselapiCommonVesselDataContractsTypesPortCountry `json:"country,omitempty"`

	// GarbageDisposal Whether garbage disposal services are available
	GarbageDisposal *bool `json:"garbage_disposal,omitempty"`

	// HarborSize Harbor size classification (Large/Medium/Small/Very Small)
	HarborSize *string `json:"harbor_size,omitempty"`

	// HarborType Type of harbor (CB=Coastal Breakwater, CN=Coastal Natural, etc.)
	HarborType *string `json:"harbor_type,omitempty"`

	// HarborUse Primary use of the harbor (FISH/MIL/CARGO/FERRY/UNK)
	HarborUse *string `json:"harbor_use,omitempty"`

	// HasDrydock Whether the port has drydock facilities
	HasDrydock *bool `json:"has_drydock,omitempty"`

	// Latitude Geographic latitude in decimal degrees
	Latitude *float64 `json:"latitude,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Longitude Geographic longitude in decimal degrees
	Longitude *float64 `json:"longitude,omitempty"`

	// MaxVesselBeam Maximum beam (width) of vessel that can be accommodated
	MaxVesselBeam *float32 `json:"max_vessel_beam,omitempty"`

	// MaxVesselBeamUnit Unit for maximum vessel beam
	MaxVesselBeamUnit *string `json:"max_vessel_beam_unit,omitempty"`

	// MaxVesselDraft Maximum draft of vessel that can be accommodated
	MaxVesselDraft *float32 `json:"max_vessel_draft,omitempty"`

	// MaxVesselDraftUnit Unit for maximum vessel draft
	MaxVesselDraftUnit *string `json:"max_vessel_draft_unit,omitempty"`

	// MaxVesselLength Maximum length of vessel that can be accommodated
	MaxVesselLength *float32 `json:"max_vessel_length,omitempty"`

	// MaxVesselLengthUnit Unit for maximum vessel length
	MaxVesselLengthUnit *string `json:"max_vessel_length_unit,omitempty"`

	// MedicalFacilities Whether medical facilities are available at the port
	MedicalFacilities *bool `json:"medical_facilities,omitempty"`

	// Name The port's official name
	Name *string `json:"name,omitempty"`

	// NavigationArea NAVAREA designation for maritime safety communications
	NavigationArea *string `json:"navigation_area,omitempty"`

	// PilotageAvailable Whether pilotage services are available
	PilotageAvailable *bool `json:"pilotage_available,omitempty"`

	// PilotageCompulsory Whether pilotage is mandatory for vessel entry
	PilotageCompulsory *bool `json:"pilotage_compulsory,omitempty"`

	// PortSecurity Whether ISPS (International Ship and Port Facility Security) compliant
	PortSecurity *bool `json:"port_security,omitempty"`

	// RegionName Geographic region where the port is located
	RegionName *string `json:"region_name,omitempty"`

	// RepairCapability Level of ship repair capability (Major/Moderate/Limited/Emergency/None)
	RepairCapability *string `json:"repair_capability,omitempty"`

	// Shelter Quality of shelter from weather (Excellent/Good/Fair/Poor/None)
	Shelter *string `json:"shelter,omitempty"`

	// Size Size classification of the port
	Size *string `json:"size,omitempty"`

	// SupplyDiesel Whether diesel supply is available
	SupplyDiesel *bool `json:"supply_diesel,omitempty"`

	// SupplyFuel Whether fuel oil supply is available
	SupplyFuel *bool `json:"supply_fuel,omitempty"`

	// SupplyWater Whether fresh water supply is available
	SupplyWater *bool `json:"supply_water,omitempty"`

	// TrafficSeparationScheme Whether a TSS (Traffic Separation Scheme) is in place
	TrafficSeparationScheme *bool `json:"traffic_separation_scheme,omitempty"`

	// TugsAvailable Whether tug services are available
	TugsAvailable *bool `json:"tugs_available,omitempty"`

	// Type Port classification type
	Type *string `json:"type,omitempty"`

	// UnloCode UN Location Code (LOCODE) - unique port identifier
	UnloCode *string `json:"unlo_code,omitempty"`

	// VesselTrafficService Whether VTS (Vessel Traffic Service) is operational
	VesselTrafficService *bool `json:"vessel_traffic_service,omitempty"`
}

// PortEvent Vessel port call event including arrivals and departures
type PortEvent struct {
	// Event Type of port event - either "Arrival" or "Departure"
	Event *string `json:"event,omitempty"`

	// Port Reference to the port where the event occurred
	Port *GithubComVesselapiCommonVesselDataContractsTypesPortReference `json:"port,omitempty"`

	// Timestamp UTC timestamp when the event occurred
	Timestamp *string `json:"timestamp,omitempty"`

	// Vessel Reference to the vessel involved in the port event
	Vessel *GithubComVesselapiCommonVesselDataContractsTypesVesselReference `json:"vessel,omitempty"`
}

// PortEventResponse Response containing a single port event
type PortEventResponse struct {
	// PortEvent Vessel port call event including arrivals and departures
	PortEvent *PortEvent `json:"portEvent,omitempty"`
}

// PortEventsResponse Response containing port event data
type PortEventsResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// PortEvents List of port events
	PortEvents *[]PortEvent `json:"portEvents,omitempty"`
}

// PortResponse Response containing a single port
type PortResponse struct {
	// Port Complete port information including facilities, services, and characteristics
	Port *Port `json:"port,omitempty"`
}

// PortsWithinLocationResponse Response containing ports within location data
type PortsWithinLocationResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// Ports List of ports within the specified area
	Ports *[]Port `json:"ports,omitempty"`
}

// RadioBeacon Navigational radio beacon for maritime direction finding
type RadioBeacon struct {
	// AidType Type of radio aid
	AidType *string `json:"aid_type,omitempty"`

	// Characteristic Beacon transmission characteristic
	Characteristic *string `json:"characteristic,omitempty"`

	// DeleteFlag Deletion status flag
	DeleteFlag *string `json:"delete_flag,omitempty"`

	// FeatureNumber NGA feature number identifier
	FeatureNumber *int `json:"feature_number,omitempty"`

	// Frequency Broadcast frequency
	Frequency *string `json:"frequency,omitempty"`

	// GeopoliticalHeading Country or major geographic area
	GeopoliticalHeading *string `json:"geopolitical_heading,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Name Name of the radio beacon
	Name *string `json:"name,omitempty"`

	// NoticeNumber Notice to Mariners number
	NoticeNumber *int `json:"notice_number,omitempty"`

	// NoticeWeek Week of the notice
	NoticeWeek *string `json:"notice_week,omitempty"`

	// NoticeYear Year of the notice
	NoticeYear *string `json:"notice_year,omitempty"`

	// Position Human-readable position description
	Position *string `json:"position,omitempty"`

	// PostNote Notes appearing after the main entry
	PostNote *string `json:"post_note,omitempty"`

	// PrecedingNote Notes appearing before the main entry
	PrecedingNote *string `json:"preceding_note,omitempty"`

	// Range Signal range in nautical miles
	Range *string `json:"range,omitempty"`

	// RegionHeading Regional geographic subdivision
	RegionHeading *string `json:"region_heading,omitempty"`

	// RemoveFromList Flag indicating if entry should be removed
	RemoveFromList *string `json:"remove_from_list,omitempty"`

	// SequenceText Transmission sequence description
	SequenceText *string `json:"sequence_text,omitempty"`

	// StationRemark Remarks specific to the station
	StationRemark *string `json:"station_remark,omitempty"`

	// VolumeNumber NGA publication volume number
	VolumeNumber *string `json:"volume_number,omitempty"`
}

// RadioBeaconsWithinLocationResponse Response containing radio beacons within location data
type RadioBeaconsWithinLocationResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// RadioBeacons List of radio beacons within the specified area
	RadioBeacons *[]RadioBeacon `json:"radioBeacons,omitempty"`
}

// RateLimitErrorDetail Detailed rate limit error information
type RateLimitErrorDetail struct {
	// Code is a short string identifier for this error for programmatic handling
	Code *ErrorCode `json:"code,omitempty"`

	// Message is a human-readable message providing more details about the error
	Message *string `json:"message,omitempty"`

	// Type categorizes the error (always "rate_limit_error" for 429s)
	Type *ErrorType `json:"type,omitempty"`
}

// RateLimitErrorResponse Response returned when the API rate limit is exceeded (HTTP 429)
type RateLimitErrorResponse struct {
	// Error Detailed rate limit error information
	Error *RateLimitErrorDetail `json:"error,omitempty"`
}

// Vessel Complete vessel static data including identification, dimensions, and ownership
type Vessel struct {
	// Breadth Maximum beam (width) of the vessel
	Breadth *int `json:"breadth,omitempty"`

	// BreadthUnit Unit of measurement for breadth (typically meters)
	BreadthUnit *string `json:"breadth_unit,omitempty"`

	// Builder Name of the shipyard that built the vessel
	Builder *string `json:"builder,omitempty"`

	// CallSign International radio call sign assigned to the vessel
	CallSign *string `json:"call_sign,omitempty"`

	// ClassSociety Classification society responsible for vessel certification
	ClassSociety *string `json:"class_society,omitempty"`

	// Country Country of registration (flag state)
	Country *string `json:"country,omitempty"`

	// CountryCode ISO 2-letter country code of flag state
	CountryCode *string `json:"country_code,omitempty"`

	// DeadweightTonnage Deadweight tonnage (DWT) - maximum cargo capacity in metric tons
	DeadweightTonnage *int `json:"deadweight_tonnage,omitempty"`

	// Draft Maximum draft (depth below waterline) of the vessel
	Draft *int `json:"draft,omitempty"`

	// DraftUnit Unit of measurement for draft (typically meters)
	DraftUnit *string `json:"draft_unit,omitempty"`

	// EngineModelName Model name of the main engine
	EngineModelName *string `json:"engine_model_name,omitempty"`

	// EngineType Type code for the main engine
	EngineType *int `json:"engine_type,omitempty"`

	// FormerNames List of previous names the vessel has operated under
	FormerNames *[]GithubComVesselapiCommonVesselDataContractsTypesVesselFormerName `json:"former_names,omitempty"`

	// GrossTonnage Gross tonnage (GT) - measure of vessel's overall internal volume
	GrossTonnage *int `json:"gross_tonnage,omitempty"`

	// HomePort Port of registry for the vessel
	HomePort *string `json:"home_port,omitempty"`

	// Imo IMO International Maritime Organization number - permanent 7-digit vessel identifier
	Imo *int `json:"imo,omitempty"`

	// KilowattPower Main engine power in kilowatts
	KilowattPower *int `json:"kilowatt_power,omitempty"`

	// Length Overall length of the vessel
	Length *int `json:"length,omitempty"`

	// LengthUnit Unit of measurement for length (typically meters)
	LengthUnit *string `json:"length_unit,omitempty"`

	// ManagerName Ship management company responsible for operations
	ManagerName *string `json:"manager_name,omitempty"`

	// Mmsi MMSI Maritime Mobile Service Identity - 9-digit radio identifier
	Mmsi *int `json:"mmsi,omitempty"`

	// Name The vessel's current registered name
	Name *string `json:"name,omitempty"`

	// OperatingStatus Current operational status (e.g., Active, Laid Up, Scrapped)
	OperatingStatus *string `json:"operating_status,omitempty"`

	// OwnerName Registered owner of the vessel
	OwnerName *string `json:"owner_name,omitempty"`

	// VesselType Classification of vessel type (e.g., Container Ship, Bulk Carrier)
	VesselType *string `json:"vessel_type,omitempty"`

	// YearBuilt Year the vessel was constructed
	YearBuilt *int `json:"year_built,omitempty"`
}

// VesselETA Vessel Estimated Time of Arrival information from AIS static/voyage data
type VesselETA struct {
	// Destination Reported destination port or area as entered by the vessel
	Destination *string `json:"destination,omitempty"`

	// Draught Current draught (draft) of the vessel in meters
	Draught *float32 `json:"draught,omitempty"`

	// Eta ETA Estimated time of arrival at destination as reported by the vessel
	Eta *string `json:"eta,omitempty"`

	// Imo IMO International Maritime Organization number - permanent vessel identifier
	Imo *int `json:"imo,omitempty"`

	// Mmsi MMSI Maritime Mobile Service Identity - unique 9-digit vessel identifier
	Mmsi *int `json:"mmsi,omitempty"`

	// Timestamp UTC timestamp when this ETA information was received
	Timestamp *string `json:"timestamp,omitempty"`

	// VesselName The vessel's registered name as reported in AIS
	VesselName *string `json:"vessel_name,omitempty"`
}

// VesselETAResponse Response containing vessel ETA data
type VesselETAResponse struct {
	// VesselEta Vessel Estimated Time of Arrival information from AIS static/voyage data
	VesselEta *VesselETA `json:"vesselEta,omitempty"`
}

// VesselEmission EU MRV vessel emissions report including CO2 emissions, fuel consumption, and efficiency metrics
type VesselEmission struct {
	// Co2EmissionsAtBerth CO2 emitted while at berth in metric tonnes
	Co2EmissionsAtBerth *float32 `json:"co2_emissions_at_berth,omitempty"`

	// Co2EmissionsOnLadenVoyages CO2 emitted during laden voyages in metric tonnes
	Co2EmissionsOnLadenVoyages *float32 `json:"co2_emissions_on_laden_voyages,omitempty"`

	// Co2EmissionsTotal CO2 emissions
	Co2EmissionsTotal *float32 `json:"co2_emissions_total,omitempty"`

	// Co2PerDistance kg CO₂ / n mile
	Co2PerDistance *float32 `json:"co2_per_distance,omitempty"`

	// Co2PerTransportWork g CO₂ / m tonnes · n miles
	Co2PerTransportWork *float32 `json:"co2_per_transport_work,omitempty"`

	// CollectedAt UTC timestamp when data was collected
	CollectedAt *string `json:"collected_at,omitempty"`

	// DistanceThroughIce nautical miles
	DistanceThroughIce *float32 `json:"distance_through_ice,omitempty"`

	// DocExpiryDate Document of Compliance expiry date
	DocExpiryDate *string `json:"doc_expiry_date,omitempty"`

	// DocIssueDate DOC info
	DocIssueDate *string `json:"doc_issue_date,omitempty"`

	// FlagCode ISO country code of the flag state
	FlagCode *string `json:"flag_code,omitempty"`

	// FlagName Full name of the flag state
	FlagName *string `json:"flag_name,omitempty"`

	// FuelConsumptionHfo Heavy Fuel Oil consumption in metric tonnes
	FuelConsumptionHfo *float32 `json:"fuel_consumption_hfo,omitempty"`

	// FuelConsumptionLfo Light Fuel Oil consumption in metric tonnes
	FuelConsumptionLfo *float32 `json:"fuel_consumption_lfo,omitempty"`

	// FuelConsumptionLng Liquefied Natural Gas consumption in metric tonnes
	FuelConsumptionLng *float32 `json:"fuel_consumption_lng,omitempty"`

	// FuelConsumptionMdo Marine Diesel Oil consumption in metric tonnes
	FuelConsumptionMdo *float32 `json:"fuel_consumption_mdo,omitempty"`

	// FuelConsumptionMgo Marine Gas Oil consumption in metric tonnes
	FuelConsumptionMgo *float32 `json:"fuel_consumption_mgo,omitempty"`

	// FuelConsumptionOther Other fuel types consumption in metric tonnes
	FuelConsumptionOther *float32 `json:"fuel_consumption_other,omitempty"`

	// FuelConsumptionTotal Fuel consumption (tonnes)
	FuelConsumptionTotal *float32 `json:"fuel_consumption_total,omitempty"`

	// FuelPerDistance Efficiency metrics (pre-calculated)
	FuelPerDistance *float32 `json:"fuel_per_distance,omitempty"`

	// FuelPerTransportWork g / m tonnes · n miles
	FuelPerTransportWork *float32 `json:"fuel_per_transport_work,omitempty"`

	// HomePort Port of registry
	HomePort *string `json:"home_port,omitempty"`

	// IceClass Ice class designation
	IceClass *string `json:"ice_class,omitempty"`

	// Imo Identifiers
	Imo *int `json:"imo,omitempty"`

	// MonitoringMethodA Monitoring method
	MonitoringMethodA *string `json:"monitoring_method_a,omitempty"`

	// MonitoringMethodB Monitoring method B description
	MonitoringMethodB *string `json:"monitoring_method_b,omitempty"`

	// MonitoringMethodC Monitoring method C description
	MonitoringMethodC *string `json:"monitoring_method_c,omitempty"`

	// MonitoringMethodD Monitoring method D description
	MonitoringMethodD *string `json:"monitoring_method_d,omitempty"`

	// Name Vessel name
	Name *string `json:"name,omitempty"`

	// PortCallsOutsideEu Number of port calls outside the EU
	PortCallsOutsideEu *int `json:"port_calls_outside_eu,omitempty"`

	// PortCallsWithinEu EU specific
	PortCallsWithinEu *int `json:"port_calls_within_eu,omitempty"`

	// ReportingPeriod Reporting period
	ReportingPeriod *string `json:"reporting_period,omitempty"`

	// SourceUrl Metadata
	SourceUrl *string `json:"source_url,omitempty"`

	// TechnicalEfficiency Technical efficiency
	TechnicalEfficiency *string `json:"technical_efficiency,omitempty"`

	// TechnicalEfficiencyValue Numeric value of the technical efficiency metric
	TechnicalEfficiencyValue *float32 `json:"technical_efficiency_value,omitempty"`

	// TimeAtSeaThroughIce hours
	TimeAtSeaThroughIce *float32 `json:"time_at_sea_through_ice,omitempty"`

	// TotalTimeAtSea Distance and time
	TotalTimeAtSea *float32 `json:"total_time_at_sea,omitempty"`

	// UniqueKey Unique key for upsert (imo_period)
	UniqueKey *string `json:"unique_key,omitempty"`

	// VerifierAccreditation Accreditation details of the verifier
	VerifierAccreditation *string `json:"verifier_accreditation,omitempty"`

	// VerifierAddress Address of the verification body
	VerifierAddress *string `json:"verifier_address,omitempty"`

	// VerifierName Verifier info
	VerifierName *string `json:"verifier_name,omitempty"`

	// VesselType Vessel identification
	VesselType *string `json:"vessel_type,omitempty"`
}

// VesselEmissionsResponse Response containing vessel emissions data
type VesselEmissionsResponse struct {
	// Emissions List of vessel emission records
	Emissions *[]VesselEmission `json:"emissions,omitempty"`

	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`
}

// VesselPosition Real-time vessel position data derived from AIS messages
type VesselPosition struct {
	// Cog COG Course Over Ground in degrees (0-359.9), null when unavailable
	Cog *float32 `json:"cog,omitempty"`

	// Heading True heading in degrees (0-359), null when unavailable
	Heading *int `json:"heading,omitempty"`

	// Imo IMO International Maritime Organization number - permanent vessel identifier
	Imo *int `json:"imo,omitempty"`

	// Latitude Geographic latitude in decimal degrees (-90 to 90)
	Latitude *float64 `json:"latitude,omitempty"`

	// Location GeoJSON point for geospatial queries
	Location *GithubComVesselapiCommonVesselDataContractsTypesGeoJSON `json:"location,omitempty"`

	// Longitude Geographic longitude in decimal degrees (-180 to 180)
	Longitude *float64 `json:"longitude,omitempty"`

	// Mmsi MMSI Maritime Mobile Service Identity - unique 9-digit vessel identifier
	Mmsi *int `json:"mmsi,omitempty"`

	// NavStatus AIS navigational status (0=under way using engine, 1=at anchor, 2=not under command, 3=restricted manoeuvrability, 5=moored, 8=under way sailing, etc.), null when unavailable
	NavStatus *int `json:"nav_status,omitempty"`

	// ProcessedTimestamp UTC timestamp when the position was processed by the system
	ProcessedTimestamp *string `json:"processed_timestamp,omitempty"`

	// Sog SOG Speed Over Ground in knots (0-102.2), null when unavailable
	Sog *float32 `json:"sog,omitempty"`

	// SuspectedGlitch indicates the position may be unreliable due to a GPS glitch or corrupted AIS transmission (implies impossible vessel speed)
	SuspectedGlitch *bool `json:"suspected_glitch,omitempty"`

	// Timestamp UTC timestamp when the AIS message was transmitted by the vessel
	Timestamp *string `json:"timestamp,omitempty"`

	// VesselName The vessel's registered name as reported in AIS
	VesselName *string `json:"vessel_name,omitempty"`
}

// VesselPositionResponse Response containing a single vessel position
type VesselPositionResponse struct {
	// VesselPosition Real-time vessel position data derived from AIS messages
	VesselPosition *VesselPosition `json:"vesselPosition,omitempty"`
}

// VesselPositionsResponse Response containing vessel position data
type VesselPositionsResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// VesselPositions List of vessel position records
	VesselPositions *[]VesselPosition `json:"vesselPositions,omitempty"`
}

// VesselResponse Response containing vessel data
type VesselResponse struct {
	// Vessel Complete vessel static data including identification, dimensions, and ownership
	Vessel *Vessel `json:"vessel,omitempty"`
}

// VesselsWithinLocationResponse Response containing vessel within location data
type VesselsWithinLocationResponse struct {
	// NextToken Opaque token for fetching the next page, or null if no more results
	NextToken *string `json:"nextToken,omitempty"`

	// Vessels List of vessel positions within the specified area
	Vessels *[]VesselPosition `json:"vessels,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesBroadcastStation NAVTEX radio broadcast station details
type GithubComVesselapiCommonVesselDataContractsTypesBroadcastStation struct {
	// Country Country where the station is located
	Country *string `json:"country,omitempty"`

	// Coverage Description of the broadcast coverage area
	Coverage *string `json:"coverage,omitempty"`

	// Latitude Geographic latitude of the station
	Latitude *float64 `json:"latitude,omitempty"`

	// Longitude Geographic longitude of the station
	Longitude *float64 `json:"longitude,omitempty"`

	// Name Station name
	Name *string `json:"name,omitempty"`

	// StationId StationID Unique station identifier character
	StationId *string `json:"station_id,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationCertificate Vessel classification certificate record
type GithubComVesselapiCommonVesselDataContractsTypesClassificationCertificate struct {
	// Certificate Certificate name
	Certificate *string `json:"certificate,omitempty"`

	// Code Certificate code identifier
	Code *string `json:"code,omitempty"`

	// Expires Expiry date of the certificate
	Expires *string `json:"expires,omitempty"`

	// ExtUntil Extended validity date
	ExtUntil *string `json:"extUntil,omitempty"`

	// Issued Issue date of the certificate
	Issued *string `json:"issued,omitempty"`

	// Term Certificate validity term
	Term *string `json:"term,omitempty"`

	// Type Certificate type classification
	Type *string `json:"type,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationCondition Classification condition of class imposed on a vessel
type GithubComVesselapiCommonVesselDataContractsTypesClassificationCondition struct {
	// Condition Condition description text
	Condition *string `json:"condition,omitempty"`

	// DueDate Date by which the condition must be met
	DueDate *string `json:"dueDate,omitempty"`

	// ImposedDate Date when the condition was imposed
	ImposedDate *string `json:"imposedDate,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationDimensions Vessel dimensional measurements from classification records
type GithubComVesselapiCommonVesselDataContractsTypesClassificationDimensions struct {
	// Bm Breadth moulded in meters
	Bm *float32 `json:"bm,omitempty"`

	// Dm Depth moulded in meters
	Dm *float32 `json:"dm,omitempty"`

	// Draught Maximum draught in meters
	Draught *float32 `json:"draught,omitempty"`

	// Dwt Deadweight tonnage in metric tonnes
	Dwt *float32 `json:"dwt,omitempty"`

	// GrossTon69 Gross tonnage under 1969 convention
	GrossTon69 *float32 `json:"grossTon69,omitempty"`

	// Lbp Length between perpendiculars in meters
	Lbp *float32 `json:"lbp,omitempty"`

	// LengthOverall Overall length of the vessel in meters
	LengthOverall *float32 `json:"lengthOverall,omitempty"`

	// NetTon69 Net tonnage under 1969 convention
	NetTon69 *float32 `json:"netTon69,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationHull Vessel hull construction details
type GithubComVesselapiCommonVesselDataContractsTypesClassificationHull struct {
	// DecksNumber Number of decks
	DecksNumber *string `json:"decksNumber,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationIdentification Vessel identification details from classification society records
type GithubComVesselapiCommonVesselDataContractsTypesClassificationIdentification struct {
	// ClassStatusString Current class status description
	ClassStatusString *string `json:"classStatusString,omitempty"`

	// FlagCode ISO country code of flag state
	FlagCode *string `json:"flagCode,omitempty"`

	// FlagName Full name of the flag state
	FlagName *string `json:"flagName,omitempty"`

	// HomePort Port of registry
	HomePort *string `json:"homePort,omitempty"`

	// ImoNumber IMO number as string
	ImoNumber *string `json:"imoNumber,omitempty"`

	// NonClassRelationString Non-class relation status description
	NonClassRelationString *string `json:"nonClassRelationString,omitempty"`

	// OfficialNumber Official registration number
	OfficialNumber *string `json:"officialNumber,omitempty"`

	// OperationalStatusString Current operational status description
	OperationalStatusString *string `json:"operationalStatusString,omitempty"`

	// Purposes List of vessel purpose designations
	Purposes *[]GithubComVesselapiCommonVesselDataContractsTypesClassificationPurpose `json:"purposes,omitempty"`

	// Register Classification register identifier
	Register *string `json:"register,omitempty"`

	// SignalLetters Radio call sign letters
	SignalLetters *string `json:"signalLetters,omitempty"`

	// TypeFormatted Formatted vessel type description
	TypeFormatted *string `json:"typeFormatted,omitempty"`

	// VesselId Classification society vessel identifier
	VesselId *string `json:"vesselId,omitempty"`

	// VesselName Vessel name in classification records
	VesselName *string `json:"vesselName,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationInfo Classification society notation and status information
type GithubComVesselapiCommonVesselDataContractsTypesClassificationInfo struct {
	// ClassEntryDate Date when the vessel entered class
	ClassEntryDate *string `json:"classEntryDate,omitempty"`

	// ClassNotationString Full class notation string
	ClassNotationString *string `json:"classNotationString,omitempty"`

	// ClassNotationStringDesign Design class notation string
	ClassNotationStringDesign *string `json:"classNotationStringDesign,omitempty"`

	// ClassNotationStringInOperation In-operation class notation string
	ClassNotationStringInOperation *string `json:"classNotationStringInOperation,omitempty"`

	// ClassNotationStringMain Main class notation string
	ClassNotationStringMain *string `json:"classNotationStringMain,omitempty"`

	// ConstructionSymbol Construction symbol designation
	ConstructionSymbol *string `json:"constructionSymbol,omitempty"`

	// DualClass Dual classification society designation
	DualClass *string `json:"dualClass,omitempty"`

	// EquipmentNumber Equipment number from classification
	EquipmentNumber *string `json:"equipmentNumber,omitempty"`

	// LastClassificationSociety Previous classification society name
	LastClassificationSociety *string `json:"lastClassificationSociety,omitempty"`

	// MainClass Main class designation
	MainClass *string `json:"mainClass,omitempty"`

	// MainClassMachinery Main class machinery designation
	MainClassMachinery *string `json:"mainClassMachinery,omitempty"`

	// RegisterNotationString Register notation string
	RegisterNotationString *string `json:"registerNotationString,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationMachinery Vessel machinery and propulsion details
type GithubComVesselapiCommonVesselDataContractsTypesClassificationMachinery struct {
	// MainPropulsion Main propulsion type description
	MainPropulsion *string `json:"mainPropulsion,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationOwner Vessel owner and management company details from classification records
type GithubComVesselapiCommonVesselDataContractsTypesClassificationOwner struct {
	// DocHolderDnvId DOC holder DNV identifier
	DocHolderDnvId *string `json:"docHolderDnvId,omitempty"`

	// DocHolderImoNumber DOC holder IMO company number
	DocHolderImoNumber *string `json:"docHolderImoNumber,omitempty"`

	// DocHolderName DOC holder company name
	DocHolderName *string `json:"docHolderName,omitempty"`

	// ManagerDnvId Ship manager DNV identifier
	ManagerDnvId *string `json:"managerDnvId,omitempty"`

	// ManagerImoNumber Ship manager IMO company number
	ManagerImoNumber *string `json:"managerImoNumber,omitempty"`

	// ManagerName Ship manager company name
	ManagerName *string `json:"managerName,omitempty"`

	// OwnerDnvId Registered owner DNV identifier
	OwnerDnvId *string `json:"ownerDnvId,omitempty"`

	// OwnerImoNumber Registered owner IMO company number
	OwnerImoNumber *string `json:"ownerImoNumber,omitempty"`

	// OwnerName Registered owner company name
	OwnerName *string `json:"ownerName,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationPurpose Vessel purpose designation from classification records
type GithubComVesselapiCommonVesselDataContractsTypesClassificationPurpose struct {
	// Description Detailed purpose description
	Description *string `json:"description,omitempty"`

	// IsMainPurpose Whether this is the primary vessel purpose
	IsMainPurpose *bool `json:"isMainPurpose,omitempty"`

	// Purpose Purpose code or short name
	Purpose *string `json:"purpose,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationSurvey Survey record from classification society
type GithubComVesselapiCommonVesselDataContractsTypesClassificationSurvey struct {
	// Category Survey category classification
	Category *string `json:"category,omitempty"`

	// DueFrom Earliest date the survey may be performed
	DueFrom *string `json:"dueFrom,omitempty"`

	// DueTo Latest date the survey must be completed
	DueTo *string `json:"dueTo,omitempty"`

	// LastDate Date of the most recent survey
	LastDate *string `json:"lastDate,omitempty"`

	// Location Location where the survey was performed
	Location *string `json:"location,omitempty"`

	// Postponed Postponement date if the survey was deferred
	Postponed *string `json:"postponed,omitempty"`

	// Survey Survey type name
	Survey *string `json:"survey,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesClassificationYard Shipyard and construction details from classification records
type GithubComVesselapiCommonVesselDataContractsTypesClassificationYard struct {
	// ContractedBuilder Contracted shipbuilder name
	ContractedBuilder *string `json:"contractedBuilder,omitempty"`

	// ContractedBuilderBuildNo Build number assigned by the contracted builder
	ContractedBuilderBuildNo *string `json:"contractedBuilderBuildNo,omitempty"`

	// DateOfBuild Date when construction was completed
	DateOfBuild *string `json:"dateOfBuild,omitempty"`

	// HullYardBuildNo Build number assigned by the hull yard
	HullYardBuildNo *string `json:"hullYardBuildNo,omitempty"`

	// HullYardName Name of the hull construction yard
	HullYardName *string `json:"hullYardName,omitempty"`

	// KeelDate Keel laying date
	KeelDate *string `json:"keelDate,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesGeoJSON GeoJSON Point geometry for geospatial coordinates
type GithubComVesselapiCommonVesselDataContractsTypesGeoJSON struct {
	// Coordinates Array of [longitude, latitude] in decimal degrees
	Coordinates *[]float32 `json:"coordinates,omitempty"`

	// Type GeoJSON geometry type, always "Point" for location data
	Type *string `json:"type,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesPortCountry Country information for port location
type GithubComVesselapiCommonVesselDataContractsTypesPortCountry struct {
	// Code ISO 2-letter country code
	Code *string `json:"code,omitempty"`

	// Name Full country name
	Name *string `json:"name,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesPortReference Port identification details for port event reference
type GithubComVesselapiCommonVesselDataContractsTypesPortReference struct {
	// Country Country where the port is located
	Country *string `json:"country,omitempty"`

	// Name The port's official name
	Name *string `json:"name,omitempty"`

	// UnloCode UN Location Code (LOCODE) for the port
	UnloCode *string `json:"unlo_code,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesVesselFormerName Historical vessel name record
type GithubComVesselapiCommonVesselDataContractsTypesVesselFormerName struct {
	// Name Previous name of the vessel
	Name *string `json:"name,omitempty"`

	// YearUntil Year until which this name was used
	YearUntil *string `json:"year_until,omitempty"`
}

// GithubComVesselapiCommonVesselDataContractsTypesVesselReference Vessel identification details for port event reference
type GithubComVesselapiCommonVesselDataContractsTypesVesselReference struct {
	// Imo IMO International Maritime Organization number
	Imo *int `json:"imo,omitempty"`

	// Mmsi MMSI Maritime Mobile Service Identity number
	Mmsi *int `json:"mmsi,omitempty"`

	// Name The vessel's registered name
	Name *string `json:"name,omitempty"`
}

// TypesInspection Port state control inspection summary record
type TypesInspection struct {
	// Authority Port state control authority that conducted the inspection
	Authority *string `json:"authority,omitempty"`

	// Deficiencies Number of deficiencies found
	Deficiencies *int `json:"deficiencies,omitempty"`

	// DetailId Unique identifier for retrieving inspection details
	DetailId *string `json:"detail_id,omitempty"`

	// Detained Whether the vessel was detained
	Detained *bool `json:"detained,omitempty"`

	// Imo IMO number of the inspected vessel
	Imo *int `json:"imo,omitempty"`

	// InspectionDate Date when the inspection was conducted
	InspectionDate *string `json:"inspection_date,omitempty"`

	// InspectionType Type of inspection performed
	InspectionType *string `json:"inspection_type,omitempty"`

	// MouRegion Memorandum of Understanding region (e.g., Paris MOU, Tokyo MOU)
	MouRegion *string `json:"mou_region,omitempty"`

	// Port Port where the inspection took place
	Port *string `json:"port,omitempty"`
}

// TypesInspectionDeficiency Inspection deficiency record with category and count
type TypesInspectionDeficiency struct {
	// Category Deficiency category classification
	Category *string `json:"category,omitempty"`

	// Count Number of deficiencies in this category
	Count *int `json:"count,omitempty"`

	// Deficiency Deficiency description
	Deficiency *string `json:"deficiency,omitempty"`
}

// TypesInspectionDetail Detailed port state control inspection record including deficiencies
type TypesInspectionDetail struct {
	// Authority Port state control authority that conducted the inspection
	Authority *string `json:"authority,omitempty"`

	// Deficiencies List of deficiency records
	Deficiencies *[]TypesInspectionDeficiency `json:"deficiencies,omitempty"`

	// DeficiencyCount Total number of deficiencies found
	DeficiencyCount *int `json:"deficiency_count,omitempty"`

	// DetailId Unique inspection detail identifier
	DetailId *string `json:"detail_id,omitempty"`

	// Detained Whether the vessel was detained
	Detained *bool `json:"detained,omitempty"`

	// DetentionGrounds Grounds for detention if the vessel was detained
	DetentionGrounds *[]TypesInspectionDeficiency `json:"detention_grounds,omitempty"`

	// Imo IMO number of the inspected vessel
	Imo *int `json:"imo,omitempty"`

	// InspectionDate Date when the inspection was conducted
	InspectionDate *string `json:"inspection_date,omitempty"`

	// InspectionType Type of inspection performed
	InspectionType *string `json:"inspection_type,omitempty"`

	// MouRegion Memorandum of Understanding region
	MouRegion *string `json:"mou_region,omitempty"`

	// Port Port where the inspection took place
	Port *string `json:"port,omitempty"`
}

// TypesInspectionDetailResponse Response containing detailed inspection data
type TypesInspectionDetailResponse struct {
	// CachedAt UTC timestamp when the data was cached
	CachedAt *string `json:"cached_at,omitempty"`

	// DetailId Inspection detail identifier
	DetailId *string `json:"detail_id,omitempty"`

	// Imo IMO number of the vessel
	Imo *int `json:"imo,omitempty"`

	// InspectionDetail Detailed port state control inspection record including deficiencies
	InspectionDetail *TypesInspectionDetail `json:"inspection_detail,omitempty"`
}

// TypesInspectionsResponse Response containing inspection records for a vessel
type TypesInspectionsResponse struct {
	// CachedAt UTC timestamp when the data was cached
	CachedAt *string `json:"cached_at,omitempty"`

	// Imo IMO number of the vessel
	Imo *int `json:"imo,omitempty"`

	// InspectionCount Total number of inspection records
	InspectionCount *int `json:"inspection_count,omitempty"`

	// Inspections List of inspection summary records
	Inspections *[]TypesInspection `json:"inspections,omitempty"`
}

// TypesOwnershipResponse Response containing vessel ownership and management data
type TypesOwnershipResponse struct {
	// CachedAt UTC timestamp when the data was cached
	CachedAt *string `json:"cached_at,omitempty"`

	// Imo IMO number of the vessel
	Imo *int `json:"imo,omitempty"`

	// Ownership Vessel ownership and management company details
	Ownership *TypesVesselOwnership `json:"ownership,omitempty"`
}

// TypesVesselOwnership Vessel ownership and management company details
type TypesVesselOwnership struct {
	// DocCompany Document of Compliance (DOC) issuing company
	DocCompany *string `json:"doc_company,omitempty"`

	// DocCompanyAddress Address of the DOC company
	DocCompanyAddress *string `json:"doc_company_address,omitempty"`

	// Imo IMO number of the vessel
	Imo *int `json:"imo,omitempty"`

	// RegisteredOwner Registered owner name
	RegisteredOwner *string `json:"registered_owner,omitempty"`

	// RegisteredOwnerAddress Address of the registered owner
	RegisteredOwnerAddress *string `json:"registered_owner_address,omitempty"`

	// ShipManager Ship management company name
	ShipManager *string `json:"ship_manager,omitempty"`

	// ShipManagerAddress Address of the ship management company
	ShipManagerAddress *string `json:"ship_manager_address,omitempty"`
}

// GetEmissionsParams defines parameters for GetEmissions.
type GetEmissionsParams struct {
	// FilterPeriod Reporting year filter (e.g. 2024)
	FilterPeriod *int `form:"filter.period,omitempty" json:"filter.period,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationDgpsBoundingBoxParams defines parameters for GetLocationDgpsBoundingBox.
type GetLocationDgpsBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationDgpsRadiusParams defines parameters for GetLocationDgpsRadius.
type GetLocationDgpsRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationLightaidsBoundingBoxParams defines parameters for GetLocationLightaidsBoundingBox.
type GetLocationLightaidsBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationLightaidsRadiusParams defines parameters for GetLocationLightaidsRadius.
type GetLocationLightaidsRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationModuBoundingBoxParams defines parameters for GetLocationModuBoundingBox.
type GetLocationModuBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationModuRadiusParams defines parameters for GetLocationModuRadius.
type GetLocationModuRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationPortsBoundingBoxParams defines parameters for GetLocationPortsBoundingBox.
type GetLocationPortsBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationPortsRadiusParams defines parameters for GetLocationPortsRadius.
type GetLocationPortsRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationRadiobeaconsBoundingBoxParams defines parameters for GetLocationRadiobeaconsBoundingBox.
type GetLocationRadiobeaconsBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationRadiobeaconsRadiusParams defines parameters for GetLocationRadiobeaconsRadius.
type GetLocationRadiobeaconsRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationVesselsBoundingBoxParams defines parameters for GetLocationVesselsBoundingBox.
type GetLocationVesselsBoundingBoxParams struct {
	// FilterLonLeft Longitude of the left (western) edge of the bounding box
	FilterLonLeft *float64 `form:"filter.lonLeft,omitempty" json:"filter.lonLeft,omitempty"`

	// FilterLonRight Longitude of the right (eastern) edge of the bounding box
	FilterLonRight *float64 `form:"filter.lonRight,omitempty" json:"filter.lonRight,omitempty"`

	// FilterLatBottom Latitude of the bottom (southern) edge of the bounding box
	FilterLatBottom *float64 `form:"filter.latBottom,omitempty" json:"filter.latBottom,omitempty"`

	// FilterLatTop Latitude of the top (northern) edge of the bounding box
	FilterLatTop *float64 `form:"filter.latTop,omitempty" json:"filter.latTop,omitempty"`

	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetLocationVesselsRadiusParams defines parameters for GetLocationVesselsRadius.
type GetLocationVesselsRadiusParams struct {
	// FilterLongitude Longitude of the center point
	FilterLongitude *float64 `form:"filter.longitude,omitempty" json:"filter.longitude,omitempty"`

	// FilterLatitude Latitude of the center point
	FilterLatitude *float64 `form:"filter.latitude,omitempty" json:"filter.latitude,omitempty"`

	// FilterRadius Search radius in meters (max 100,000 = 100 km)
	FilterRadius float64 `form:"filter.radius" json:"filter.radius"`

	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetNavtexParams defines parameters for GetNavtex.
type GetNavtexParams struct {
	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetPorteventsParams defines parameters for GetPortevents.
type GetPorteventsParams struct {
	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// FilterCountry Country name to filter port events by
	FilterCountry *string `form:"filter.country,omitempty" json:"filter.country,omitempty"`

	// FilterUnlocode UN/LOCODE to filter port events by
	FilterUnlocode *string `form:"filter.unlocode,omitempty" json:"filter.unlocode,omitempty"`

	// FilterEventType Event type to filter by (e.g. "arrival", "departure")
	FilterEventType *string `form:"filter.eventType,omitempty" json:"filter.eventType,omitempty"`

	// FilterVesselName Vessel name to filter port events by
	FilterVesselName *string `form:"filter.vesselName,omitempty" json:"filter.vesselName,omitempty"`

	// FilterPortName Port name to filter port events by
	FilterPortName *string `form:"filter.portName,omitempty" json:"filter.portName,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetPorteventsPortUnlocodeParams defines parameters for GetPorteventsPortUnlocode.
type GetPorteventsPortUnlocodeParams struct {
	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetPorteventsPortsParams defines parameters for GetPorteventsPorts.
type GetPorteventsPortsParams struct {
	// FilterPortName Port name
	FilterPortName string `form:"filter.portName" json:"filter.portName"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetPorteventsVesselIdParams defines parameters for GetPorteventsVesselId.
type GetPorteventsVesselIdParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetPorteventsVesselIdParamsFilterIdType `form:"filter.idType" json:"filter.idType"`

	// FilterEventType Filter by event type
	FilterEventType *GetPorteventsVesselIdParamsFilterEventType `form:"filter.eventType,omitempty" json:"filter.eventType,omitempty"`

	// FilterSortOrder Sort order by timestamp
	FilterSortOrder *GetPorteventsVesselIdParamsFilterSortOrder `form:"filter.sortOrder,omitempty" json:"filter.sortOrder,omitempty"`

	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetPorteventsVesselIdParamsFilterIdType defines parameters for GetPorteventsVesselId.
type GetPorteventsVesselIdParamsFilterIdType string

// GetPorteventsVesselIdParamsFilterEventType defines parameters for GetPorteventsVesselId.
type GetPorteventsVesselIdParamsFilterEventType string

// GetPorteventsVesselIdParamsFilterSortOrder defines parameters for GetPorteventsVesselId.
type GetPorteventsVesselIdParamsFilterSortOrder string

// GetPorteventsVesselIdLastParams defines parameters for GetPorteventsVesselIdLast.
type GetPorteventsVesselIdLastParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetPorteventsVesselIdLastParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetPorteventsVesselIdLastParamsFilterIdType defines parameters for GetPorteventsVesselIdLast.
type GetPorteventsVesselIdLastParamsFilterIdType string

// GetPorteventsVesselsParams defines parameters for GetPorteventsVessels.
type GetPorteventsVesselsParams struct {
	// FilterVesselName Vessel name
	FilterVesselName string `form:"filter.vesselName" json:"filter.vesselName"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchDgpsParams defines parameters for GetSearchDgps.
type GetSearchDgpsParams struct {
	// FilterName Name of the DGPS station
	FilterName string `form:"filter.name" json:"filter.name"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchLightaidsParams defines parameters for GetSearchLightaids.
type GetSearchLightaidsParams struct {
	// FilterName Name of the Light Aid
	FilterName string `form:"filter.name" json:"filter.name"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchModusParams defines parameters for GetSearchModus.
type GetSearchModusParams struct {
	// FilterName Name of the MODU
	FilterName string `form:"filter.name" json:"filter.name"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchPortsParams defines parameters for GetSearchPorts.
type GetSearchPortsParams struct {
	// FilterName Name of the port
	FilterName *string `form:"filter.name,omitempty" json:"filter.name,omitempty"`

	// FilterCountry Country code to filter ports by (e.g. "NL")
	FilterCountry *string `form:"filter.country,omitempty" json:"filter.country,omitempty"`

	// FilterType Port type to filter by (e.g. "Seaport")
	FilterType *string `form:"filter.type,omitempty" json:"filter.type,omitempty"`

	// FilterSize Port size to filter by
	FilterSize *string `form:"filter.size,omitempty" json:"filter.size,omitempty"`

	// FilterRegion Region to filter ports by
	FilterRegion *string `form:"filter.region,omitempty" json:"filter.region,omitempty"`

	// FilterHarborSize Harbor size to filter by
	FilterHarborSize *string `form:"filter.harborSize,omitempty" json:"filter.harborSize,omitempty"`

	// FilterHarborUse Harbor use to filter by
	FilterHarborUse *string `form:"filter.harborUse,omitempty" json:"filter.harborUse,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchRadiobeaconsParams defines parameters for GetSearchRadiobeacons.
type GetSearchRadiobeaconsParams struct {
	// FilterName Name of the Radio Beacon
	FilterName string `form:"filter.name" json:"filter.name"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetSearchVesselsParams defines parameters for GetSearchVessels.
type GetSearchVesselsParams struct {
	// FilterName Name of the vessel
	FilterName *string `form:"filter.name,omitempty" json:"filter.name,omitempty"`

	// FilterCallsign Radio callsign of the vessel
	FilterCallsign *string `form:"filter.callsign,omitempty" json:"filter.callsign,omitempty"`

	// FilterFlag Flag state of the vessel (e.g. "PA" for Panama)
	FilterFlag *string `form:"filter.flag,omitempty" json:"filter.flag,omitempty"`

	// FilterVesselType Type of vessel (e.g. "Container Ship")
	FilterVesselType *string `form:"filter.vesselType,omitempty" json:"filter.vesselType,omitempty"`

	// FilterMmsi MMSI number of the vessel
	FilterMmsi *int `form:"filter.mmsi,omitempty" json:"filter.mmsi,omitempty"`

	// FilterImo IMO number of the vessel
	FilterImo *int `form:"filter.imo,omitempty" json:"filter.imo,omitempty"`

	// FilterYearBuiltMin Minimum year built filter
	FilterYearBuiltMin *int `form:"filter.yearBuiltMin,omitempty" json:"filter.yearBuiltMin,omitempty"`

	// FilterYearBuiltMax Maximum year built filter
	FilterYearBuiltMax *int `form:"filter.yearBuiltMax,omitempty" json:"filter.yearBuiltMax,omitempty"`

	// FilterClassSociety Classification society of the vessel
	FilterClassSociety *string `form:"filter.classSociety,omitempty" json:"filter.classSociety,omitempty"`

	// FilterOwner Owner of the vessel
	FilterOwner *string `form:"filter.owner,omitempty" json:"filter.owner,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetVesselIdParams defines parameters for GetVesselId.
type GetVesselIdParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdParamsFilterIdType defines parameters for GetVesselId.
type GetVesselIdParamsFilterIdType string

// GetVesselIdCasualtiesParams defines parameters for GetVesselIdCasualties.
type GetVesselIdCasualtiesParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdCasualtiesParamsFilterIdType `form:"filter.idType" json:"filter.idType"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetVesselIdCasualtiesParamsFilterIdType defines parameters for GetVesselIdCasualties.
type GetVesselIdCasualtiesParamsFilterIdType string

// GetVesselIdClassificationParams defines parameters for GetVesselIdClassification.
type GetVesselIdClassificationParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdClassificationParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdClassificationParamsFilterIdType defines parameters for GetVesselIdClassification.
type GetVesselIdClassificationParamsFilterIdType string

// GetVesselIdEmissionsParams defines parameters for GetVesselIdEmissions.
type GetVesselIdEmissionsParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdEmissionsParamsFilterIdType `form:"filter.idType" json:"filter.idType"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetVesselIdEmissionsParamsFilterIdType defines parameters for GetVesselIdEmissions.
type GetVesselIdEmissionsParamsFilterIdType string

// GetVesselIdEtaParams defines parameters for GetVesselIdEta.
type GetVesselIdEtaParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdEtaParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdEtaParamsFilterIdType defines parameters for GetVesselIdEta.
type GetVesselIdEtaParamsFilterIdType string

// GetVesselIdInspectionsParams defines parameters for GetVesselIdInspections.
type GetVesselIdInspectionsParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdInspectionsParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdInspectionsParamsFilterIdType defines parameters for GetVesselIdInspections.
type GetVesselIdInspectionsParamsFilterIdType string

// GetVesselIdInspectionsDetailIdParams defines parameters for GetVesselIdInspectionsDetailId.
type GetVesselIdInspectionsDetailIdParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdInspectionsDetailIdParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdInspectionsDetailIdParamsFilterIdType defines parameters for GetVesselIdInspectionsDetailId.
type GetVesselIdInspectionsDetailIdParamsFilterIdType string

// GetVesselIdOwnershipParams defines parameters for GetVesselIdOwnership.
type GetVesselIdOwnershipParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdOwnershipParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdOwnershipParamsFilterIdType defines parameters for GetVesselIdOwnership.
type GetVesselIdOwnershipParamsFilterIdType string

// GetVesselIdPositionParams defines parameters for GetVesselIdPosition.
type GetVesselIdPositionParams struct {
	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselIdPositionParamsFilterIdType `form:"filter.idType" json:"filter.idType"`
}

// GetVesselIdPositionParamsFilterIdType defines parameters for GetVesselIdPosition.
type GetVesselIdPositionParamsFilterIdType string

// GetVesselsPositionsParams defines parameters for GetVesselsPositions.
type GetVesselsPositionsParams struct {
	// FilterIds Comma-separated list of MMSI or IMO numbers
	FilterIds string `form:"filter.ids" json:"filter.ids"`

	// FilterIdType Identifier type: 'mmsi' or 'imo'
	FilterIdType GetVesselsPositionsParamsFilterIdType `form:"filter.idType" json:"filter.idType"`

	// TimeFrom Start timestamp in RFC3339 format (defaults to 2 hours ago)
	TimeFrom *string `form:"time.from,omitempty" json:"time.from,omitempty"`

	// TimeTo End timestamp in RFC3339 format (defaults to current time)
	TimeTo *string `form:"time.to,omitempty" json:"time.to,omitempty"`

	// PaginationLimit Maximum number of items to return, must be between 1 and 50
	PaginationLimit *int `form:"pagination.limit,omitempty" json:"pagination.limit,omitempty"`

	// PaginationNextToken Pagination token for retrieving the next page of results
	PaginationNextToken *string `form:"pagination.nextToken,omitempty" json:"pagination.nextToken,omitempty"`
}

// GetVesselsPositionsParamsFilterIdType defines parameters for GetVesselsPositions.
type GetVesselsPositionsParamsFilterIdType string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetEmissions request
	GetEmissions(ctx context.Context, params *GetEmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationDgpsBoundingBox request
	GetLocationDgpsBoundingBox(ctx context.Context, params *GetLocationDgpsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationDgpsRadius request
	GetLocationDgpsRadius(ctx context.Context, params *GetLocationDgpsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationLightaidsBoundingBox request
	GetLocationLightaidsBoundingBox(ctx context.Context, params *GetLocationLightaidsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationLightaidsRadius request
	GetLocationLightaidsRadius(ctx context.Context, params *GetLocationLightaidsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationModuBoundingBox request
	GetLocationModuBoundingBox(ctx context.Context, params *GetLocationModuBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationModuRadius request
	GetLocationModuRadius(ctx context.Context, params *GetLocationModuRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationPortsBoundingBox request
	GetLocationPortsBoundingBox(ctx context.Context, params *GetLocationPortsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationPortsRadius request
	GetLocationPortsRadius(ctx context.Context, params *GetLocationPortsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationRadiobeaconsBoundingBox request
	GetLocationRadiobeaconsBoundingBox(ctx context.Context, params *GetLocationRadiobeaconsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationRadiobeaconsRadius request
	GetLocationRadiobeaconsRadius(ctx context.Context, params *GetLocationRadiobeaconsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationVesselsBoundingBox request
	GetLocationVesselsBoundingBox(ctx context.Context, params *GetLocationVesselsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationVesselsRadius request
	GetLocationVesselsRadius(ctx context.Context, params *GetLocationVesselsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNavtex request
	GetNavtex(ctx context.Context, params *GetNavtexParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortUnlocode request
	GetPortUnlocode(ctx context.Context, unlocode string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPortevents request
	GetPortevents(ctx context.Context, params *GetPorteventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPorteventsPortUnlocode request
	GetPorteventsPortUnlocode(ctx context.Context, unlocode string, params *GetPorteventsPortUnlocodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPorteventsPorts request
	GetPorteventsPorts(ctx context.Context, params *GetPorteventsPortsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPorteventsVesselId request
	GetPorteventsVesselId(ctx context.Context, id string, params *GetPorteventsVesselIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPorteventsVesselIdLast request
	GetPorteventsVesselIdLast(ctx context.Context, id string, params *GetPorteventsVesselIdLastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPorteventsVessels request
	GetPorteventsVessels(ctx context.Context, params *GetPorteventsVesselsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchDgps request
	GetSearchDgps(ctx context.Context, params *GetSearchDgpsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchLightaids request
	GetSearchLightaids(ctx context.Context, params *GetSearchLightaidsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchModus request
	GetSearchModus(ctx context.Context, params *GetSearchModusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchPorts request
	GetSearchPorts(ctx context.Context, params *GetSearchPortsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchRadiobeacons request
	GetSearchRadiobeacons(ctx context.Context, params *GetSearchRadiobeaconsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchVessels request
	GetSearchVessels(ctx context.Context, params *GetSearchVesselsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselId request
	GetVesselId(ctx context.Context, id string, params *GetVesselIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdCasualties request
	GetVesselIdCasualties(ctx context.Context, id string, params *GetVesselIdCasualtiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdClassification request
	GetVesselIdClassification(ctx context.Context, id string, params *GetVesselIdClassificationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdEmissions request
	GetVesselIdEmissions(ctx context.Context, id string, params *GetVesselIdEmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdEta request
	GetVesselIdEta(ctx context.Context, id string, params *GetVesselIdEtaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdInspections request
	GetVesselIdInspections(ctx context.Context, id string, params *GetVesselIdInspectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdInspectionsDetailId request
	GetVesselIdInspectionsDetailId(ctx context.Context, id string, detailId string, params *GetVesselIdInspectionsDetailIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdOwnership request
	GetVesselIdOwnership(ctx context.Context, id string, params *GetVesselIdOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselIdPosition request
	GetVesselIdPosition(ctx context.Context, id string, params *GetVesselIdPositionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVesselsPositions request
	GetVesselsPositions(ctx context.Context, params *GetVesselsPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetEmissions(ctx context.Context, params *GetEmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmissionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationDgpsBoundingBox(ctx context.Context, params *GetLocationDgpsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationDgpsBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationDgpsRadius(ctx context.Context, params *GetLocationDgpsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationDgpsRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationLightaidsBoundingBox(ctx context.Context, params *GetLocationLightaidsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationLightaidsBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationLightaidsRadius(ctx context.Context, params *GetLocationLightaidsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationLightaidsRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationModuBoundingBox(ctx context.Context, params *GetLocationModuBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationModuBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationModuRadius(ctx context.Context, params *GetLocationModuRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationModuRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationPortsBoundingBox(ctx context.Context, params *GetLocationPortsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationPortsBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationPortsRadius(ctx context.Context, params *GetLocationPortsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationPortsRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationRadiobeaconsBoundingBox(ctx context.Context, params *GetLocationRadiobeaconsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationRadiobeaconsBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationRadiobeaconsRadius(ctx context.Context, params *GetLocationRadiobeaconsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationRadiobeaconsRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationVesselsBoundingBox(ctx context.Context, params *GetLocationVesselsBoundingBoxParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationVesselsBoundingBoxRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationVesselsRadius(ctx context.Context, params *GetLocationVesselsRadiusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationVesselsRadiusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNavtex(ctx context.Context, params *GetNavtexParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNavtexRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortUnlocode(ctx context.Context, unlocode string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPortUnlocodeRequest(c.Server, unlocode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPortevents(ctx context.Context, params *GetPorteventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPorteventsPortUnlocode(ctx context.Context, unlocode string, params *GetPorteventsPortUnlocodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsPortUnlocodeRequest(c.Server, unlocode, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPorteventsPorts(ctx context.Context, params *GetPorteventsPortsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsPortsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPorteventsVesselId(ctx context.Context, id string, params *GetPorteventsVesselIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsVesselIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPorteventsVesselIdLast(ctx context.Context, id string, params *GetPorteventsVesselIdLastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsVesselIdLastRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPorteventsVessels(ctx context.Context, params *GetPorteventsVesselsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPorteventsVesselsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchDgps(ctx context.Context, params *GetSearchDgpsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchDgpsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchLightaids(ctx context.Context, params *GetSearchLightaidsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchLightaidsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchModus(ctx context.Context, params *GetSearchModusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchModusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchPorts(ctx context.Context, params *GetSearchPortsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchPortsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchRadiobeacons(ctx context.Context, params *GetSearchRadiobeaconsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchRadiobeaconsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchVessels(ctx context.Context, params *GetSearchVesselsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchVesselsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselId(ctx context.Context, id string, params *GetVesselIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdCasualties(ctx context.Context, id string, params *GetVesselIdCasualtiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdCasualtiesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdClassification(ctx context.Context, id string, params *GetVesselIdClassificationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdClassificationRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdEmissions(ctx context.Context, id string, params *GetVesselIdEmissionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdEmissionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdEta(ctx context.Context, id string, params *GetVesselIdEtaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdEtaRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdInspections(ctx context.Context, id string, params *GetVesselIdInspectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdInspectionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdInspectionsDetailId(ctx context.Context, id string, detailId string, params *GetVesselIdInspectionsDetailIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdInspectionsDetailIdRequest(c.Server, id, detailId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdOwnership(ctx context.Context, id string, params *GetVesselIdOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdOwnershipRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselIdPosition(ctx context.Context, id string, params *GetVesselIdPositionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselIdPositionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVesselsPositions(ctx context.Context, params *GetVesselsPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVesselsPositionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetEmissionsRequest generates requests for GetEmissions
func NewGetEmissionsRequest(server string, params *GetEmissionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterPeriod != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.period", runtime.ParamLocationQuery, *params.FilterPeriod); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationDgpsBoundingBoxRequest generates requests for GetLocationDgpsBoundingBox
func NewGetLocationDgpsBoundingBoxRequest(server string, params *GetLocationDgpsBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/dgps/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationDgpsRadiusRequest generates requests for GetLocationDgpsRadius
func NewGetLocationDgpsRadiusRequest(server string, params *GetLocationDgpsRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/dgps/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationLightaidsBoundingBoxRequest generates requests for GetLocationLightaidsBoundingBox
func NewGetLocationLightaidsBoundingBoxRequest(server string, params *GetLocationLightaidsBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/lightaids/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationLightaidsRadiusRequest generates requests for GetLocationLightaidsRadius
func NewGetLocationLightaidsRadiusRequest(server string, params *GetLocationLightaidsRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/lightaids/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationModuBoundingBoxRequest generates requests for GetLocationModuBoundingBox
func NewGetLocationModuBoundingBoxRequest(server string, params *GetLocationModuBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/modu/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationModuRadiusRequest generates requests for GetLocationModuRadius
func NewGetLocationModuRadiusRequest(server string, params *GetLocationModuRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/modu/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationPortsBoundingBoxRequest generates requests for GetLocationPortsBoundingBox
func NewGetLocationPortsBoundingBoxRequest(server string, params *GetLocationPortsBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/ports/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationPortsRadiusRequest generates requests for GetLocationPortsRadius
func NewGetLocationPortsRadiusRequest(server string, params *GetLocationPortsRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/ports/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationRadiobeaconsBoundingBoxRequest generates requests for GetLocationRadiobeaconsBoundingBox
func NewGetLocationRadiobeaconsBoundingBoxRequest(server string, params *GetLocationRadiobeaconsBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/radiobeacons/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationRadiobeaconsRadiusRequest generates requests for GetLocationRadiobeaconsRadius
func NewGetLocationRadiobeaconsRadiusRequest(server string, params *GetLocationRadiobeaconsRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/radiobeacons/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationVesselsBoundingBoxRequest generates requests for GetLocationVesselsBoundingBox
func NewGetLocationVesselsBoundingBoxRequest(server string, params *GetLocationVesselsBoundingBoxParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/vessels/bounding-box")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLonLeft != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonLeft", runtime.ParamLocationQuery, *params.FilterLonLeft); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLonRight != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.lonRight", runtime.ParamLocationQuery, *params.FilterLonRight); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatBottom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latBottom", runtime.ParamLocationQuery, *params.FilterLatBottom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatTop != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latTop", runtime.ParamLocationQuery, *params.FilterLatTop); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationVesselsRadiusRequest generates requests for GetLocationVesselsRadius
func NewGetLocationVesselsRadiusRequest(server string, params *GetLocationVesselsRadiusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location/vessels/radius")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.longitude", runtime.ParamLocationQuery, *params.FilterLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.latitude", runtime.ParamLocationQuery, *params.FilterLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.radius", runtime.ParamLocationQuery, params.FilterRadius); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNavtexRequest generates requests for GetNavtex
func NewGetNavtexRequest(server string, params *GetNavtexParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/navtex")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPortUnlocodeRequest generates requests for GetPortUnlocode
func NewGetPortUnlocodeRequest(server string, unlocode string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "unlocode", runtime.ParamLocationPath, unlocode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/port/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsRequest generates requests for GetPortevents
func NewGetPorteventsRequest(server string, params *GetPorteventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.country", runtime.ParamLocationQuery, *params.FilterCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterUnlocode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.unlocode", runtime.ParamLocationQuery, *params.FilterUnlocode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterEventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.eventType", runtime.ParamLocationQuery, *params.FilterEventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVesselName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.vesselName", runtime.ParamLocationQuery, *params.FilterVesselName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterPortName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.portName", runtime.ParamLocationQuery, *params.FilterPortName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsPortUnlocodeRequest generates requests for GetPorteventsPortUnlocode
func NewGetPorteventsPortUnlocodeRequest(server string, unlocode string, params *GetPorteventsPortUnlocodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "unlocode", runtime.ParamLocationPath, unlocode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents/port/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsPortsRequest generates requests for GetPorteventsPorts
func NewGetPorteventsPortsRequest(server string, params *GetPorteventsPortsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents/ports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.portName", runtime.ParamLocationQuery, params.FilterPortName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsVesselIdRequest generates requests for GetPorteventsVesselId
func NewGetPorteventsVesselIdRequest(server string, id string, params *GetPorteventsVesselIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents/vessel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.FilterEventType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.eventType", runtime.ParamLocationQuery, *params.FilterEventType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterSortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.sortOrder", runtime.ParamLocationQuery, *params.FilterSortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsVesselIdLastRequest generates requests for GetPorteventsVesselIdLast
func NewGetPorteventsVesselIdLastRequest(server string, id string, params *GetPorteventsVesselIdLastParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents/vessel/%s/last", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPorteventsVesselsRequest generates requests for GetPorteventsVessels
func NewGetPorteventsVesselsRequest(server string, params *GetPorteventsVesselsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/portevents/vessels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.vesselName", runtime.ParamLocationQuery, params.FilterVesselName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchDgpsRequest generates requests for GetSearchDgps
func NewGetSearchDgpsRequest(server string, params *GetSearchDgpsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/dgps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchLightaidsRequest generates requests for GetSearchLightaids
func NewGetSearchLightaidsRequest(server string, params *GetSearchLightaidsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/lightaids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchModusRequest generates requests for GetSearchModus
func NewGetSearchModusRequest(server string, params *GetSearchModusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/modus")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchPortsRequest generates requests for GetSearchPorts
func NewGetSearchPortsRequest(server string, params *GetSearchPortsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/ports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, *params.FilterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCountry != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.country", runtime.ParamLocationQuery, *params.FilterCountry); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.type", runtime.ParamLocationQuery, *params.FilterType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.size", runtime.ParamLocationQuery, *params.FilterSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterRegion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.region", runtime.ParamLocationQuery, *params.FilterRegion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHarborSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.harborSize", runtime.ParamLocationQuery, *params.FilterHarborSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterHarborUse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.harborUse", runtime.ParamLocationQuery, *params.FilterHarborUse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchRadiobeaconsRequest generates requests for GetSearchRadiobeacons
func NewGetSearchRadiobeaconsRequest(server string, params *GetSearchRadiobeaconsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/radiobeacons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, params.FilterName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchVesselsRequest generates requests for GetSearchVessels
func NewGetSearchVesselsRequest(server string, params *GetSearchVesselsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/vessels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FilterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.name", runtime.ParamLocationQuery, *params.FilterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterCallsign != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.callsign", runtime.ParamLocationQuery, *params.FilterCallsign); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterFlag != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.flag", runtime.ParamLocationQuery, *params.FilterFlag); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterVesselType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.vesselType", runtime.ParamLocationQuery, *params.FilterVesselType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterMmsi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.mmsi", runtime.ParamLocationQuery, *params.FilterMmsi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterImo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.imo", runtime.ParamLocationQuery, *params.FilterImo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterYearBuiltMin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.yearBuiltMin", runtime.ParamLocationQuery, *params.FilterYearBuiltMin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterYearBuiltMax != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.yearBuiltMax", runtime.ParamLocationQuery, *params.FilterYearBuiltMax); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterClassSociety != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.classSociety", runtime.ParamLocationQuery, *params.FilterClassSociety); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FilterOwner != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.owner", runtime.ParamLocationQuery, *params.FilterOwner); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdRequest generates requests for GetVesselId
func NewGetVesselIdRequest(server string, id string, params *GetVesselIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdCasualtiesRequest generates requests for GetVesselIdCasualties
func NewGetVesselIdCasualtiesRequest(server string, id string, params *GetVesselIdCasualtiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/casualties", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdClassificationRequest generates requests for GetVesselIdClassification
func NewGetVesselIdClassificationRequest(server string, id string, params *GetVesselIdClassificationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/classification", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdEmissionsRequest generates requests for GetVesselIdEmissions
func NewGetVesselIdEmissionsRequest(server string, id string, params *GetVesselIdEmissionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/emissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdEtaRequest generates requests for GetVesselIdEta
func NewGetVesselIdEtaRequest(server string, id string, params *GetVesselIdEtaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/eta", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdInspectionsRequest generates requests for GetVesselIdInspections
func NewGetVesselIdInspectionsRequest(server string, id string, params *GetVesselIdInspectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/inspections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdInspectionsDetailIdRequest generates requests for GetVesselIdInspectionsDetailId
func NewGetVesselIdInspectionsDetailIdRequest(server string, id string, detailId string, params *GetVesselIdInspectionsDetailIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "detail_id", runtime.ParamLocationPath, detailId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/inspections/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdOwnershipRequest generates requests for GetVesselIdOwnership
func NewGetVesselIdOwnershipRequest(server string, id string, params *GetVesselIdOwnershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/ownership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselIdPositionRequest generates requests for GetVesselIdPosition
func NewGetVesselIdPositionRequest(server string, id string, params *GetVesselIdPositionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessel/%s/position", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVesselsPositionsRequest generates requests for GetVesselsPositions
func NewGetVesselsPositionsRequest(server string, params *GetVesselsPositionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vessels/positions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.ids", runtime.ParamLocationQuery, params.FilterIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.idType", runtime.ParamLocationQuery, params.FilterIdType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TimeFrom != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.from", runtime.ParamLocationQuery, *params.TimeFrom); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeTo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time.to", runtime.ParamLocationQuery, *params.TimeTo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationLimit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.limit", runtime.ParamLocationQuery, *params.PaginationLimit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PaginationNextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pagination.nextToken", runtime.ParamLocationQuery, *params.PaginationNextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetEmissionsWithResponse request
	GetEmissionsWithResponse(ctx context.Context, params *GetEmissionsParams, reqEditors ...RequestEditorFn) (*GetEmissionsResponse, error)

	// GetLocationDgpsBoundingBoxWithResponse request
	GetLocationDgpsBoundingBoxWithResponse(ctx context.Context, params *GetLocationDgpsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationDgpsBoundingBoxResponse, error)

	// GetLocationDgpsRadiusWithResponse request
	GetLocationDgpsRadiusWithResponse(ctx context.Context, params *GetLocationDgpsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationDgpsRadiusResponse, error)

	// GetLocationLightaidsBoundingBoxWithResponse request
	GetLocationLightaidsBoundingBoxWithResponse(ctx context.Context, params *GetLocationLightaidsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationLightaidsBoundingBoxResponse, error)

	// GetLocationLightaidsRadiusWithResponse request
	GetLocationLightaidsRadiusWithResponse(ctx context.Context, params *GetLocationLightaidsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationLightaidsRadiusResponse, error)

	// GetLocationModuBoundingBoxWithResponse request
	GetLocationModuBoundingBoxWithResponse(ctx context.Context, params *GetLocationModuBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationModuBoundingBoxResponse, error)

	// GetLocationModuRadiusWithResponse request
	GetLocationModuRadiusWithResponse(ctx context.Context, params *GetLocationModuRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationModuRadiusResponse, error)

	// GetLocationPortsBoundingBoxWithResponse request
	GetLocationPortsBoundingBoxWithResponse(ctx context.Context, params *GetLocationPortsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationPortsBoundingBoxResponse, error)

	// GetLocationPortsRadiusWithResponse request
	GetLocationPortsRadiusWithResponse(ctx context.Context, params *GetLocationPortsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationPortsRadiusResponse, error)

	// GetLocationRadiobeaconsBoundingBoxWithResponse request
	GetLocationRadiobeaconsBoundingBoxWithResponse(ctx context.Context, params *GetLocationRadiobeaconsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationRadiobeaconsBoundingBoxResponse, error)

	// GetLocationRadiobeaconsRadiusWithResponse request
	GetLocationRadiobeaconsRadiusWithResponse(ctx context.Context, params *GetLocationRadiobeaconsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationRadiobeaconsRadiusResponse, error)

	// GetLocationVesselsBoundingBoxWithResponse request
	GetLocationVesselsBoundingBoxWithResponse(ctx context.Context, params *GetLocationVesselsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationVesselsBoundingBoxResponse, error)

	// GetLocationVesselsRadiusWithResponse request
	GetLocationVesselsRadiusWithResponse(ctx context.Context, params *GetLocationVesselsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationVesselsRadiusResponse, error)

	// GetNavtexWithResponse request
	GetNavtexWithResponse(ctx context.Context, params *GetNavtexParams, reqEditors ...RequestEditorFn) (*GetNavtexResponse, error)

	// GetPortUnlocodeWithResponse request
	GetPortUnlocodeWithResponse(ctx context.Context, unlocode string, reqEditors ...RequestEditorFn) (*GetPortUnlocodeResponse, error)

	// GetPorteventsWithResponse request
	GetPorteventsWithResponse(ctx context.Context, params *GetPorteventsParams, reqEditors ...RequestEditorFn) (*GetPorteventsResponse, error)

	// GetPorteventsPortUnlocodeWithResponse request
	GetPorteventsPortUnlocodeWithResponse(ctx context.Context, unlocode string, params *GetPorteventsPortUnlocodeParams, reqEditors ...RequestEditorFn) (*GetPorteventsPortUnlocodeResponse, error)

	// GetPorteventsPortsWithResponse request
	GetPorteventsPortsWithResponse(ctx context.Context, params *GetPorteventsPortsParams, reqEditors ...RequestEditorFn) (*GetPorteventsPortsResponse, error)

	// GetPorteventsVesselIdWithResponse request
	GetPorteventsVesselIdWithResponse(ctx context.Context, id string, params *GetPorteventsVesselIdParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselIdResponse, error)

	// GetPorteventsVesselIdLastWithResponse request
	GetPorteventsVesselIdLastWithResponse(ctx context.Context, id string, params *GetPorteventsVesselIdLastParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselIdLastResponse, error)

	// GetPorteventsVesselsWithResponse request
	GetPorteventsVesselsWithResponse(ctx context.Context, params *GetPorteventsVesselsParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselsResponse, error)

	// GetSearchDgpsWithResponse request
	GetSearchDgpsWithResponse(ctx context.Context, params *GetSearchDgpsParams, reqEditors ...RequestEditorFn) (*GetSearchDgpsResponse, error)

	// GetSearchLightaidsWithResponse request
	GetSearchLightaidsWithResponse(ctx context.Context, params *GetSearchLightaidsParams, reqEditors ...RequestEditorFn) (*GetSearchLightaidsResponse, error)

	// GetSearchModusWithResponse request
	GetSearchModusWithResponse(ctx context.Context, params *GetSearchModusParams, reqEditors ...RequestEditorFn) (*GetSearchModusResponse, error)

	// GetSearchPortsWithResponse request
	GetSearchPortsWithResponse(ctx context.Context, params *GetSearchPortsParams, reqEditors ...RequestEditorFn) (*GetSearchPortsResponse, error)

	// GetSearchRadiobeaconsWithResponse request
	GetSearchRadiobeaconsWithResponse(ctx context.Context, params *GetSearchRadiobeaconsParams, reqEditors ...RequestEditorFn) (*GetSearchRadiobeaconsResponse, error)

	// GetSearchVesselsWithResponse request
	GetSearchVesselsWithResponse(ctx context.Context, params *GetSearchVesselsParams, reqEditors ...RequestEditorFn) (*GetSearchVesselsResponse, error)

	// GetVesselIdWithResponse request
	GetVesselIdWithResponse(ctx context.Context, id string, params *GetVesselIdParams, reqEditors ...RequestEditorFn) (*GetVesselIdResponse, error)

	// GetVesselIdCasualtiesWithResponse request
	GetVesselIdCasualtiesWithResponse(ctx context.Context, id string, params *GetVesselIdCasualtiesParams, reqEditors ...RequestEditorFn) (*GetVesselIdCasualtiesResponse, error)

	// GetVesselIdClassificationWithResponse request
	GetVesselIdClassificationWithResponse(ctx context.Context, id string, params *GetVesselIdClassificationParams, reqEditors ...RequestEditorFn) (*GetVesselIdClassificationResponse, error)

	// GetVesselIdEmissionsWithResponse request
	GetVesselIdEmissionsWithResponse(ctx context.Context, id string, params *GetVesselIdEmissionsParams, reqEditors ...RequestEditorFn) (*GetVesselIdEmissionsResponse, error)

	// GetVesselIdEtaWithResponse request
	GetVesselIdEtaWithResponse(ctx context.Context, id string, params *GetVesselIdEtaParams, reqEditors ...RequestEditorFn) (*GetVesselIdEtaResponse, error)

	// GetVesselIdInspectionsWithResponse request
	GetVesselIdInspectionsWithResponse(ctx context.Context, id string, params *GetVesselIdInspectionsParams, reqEditors ...RequestEditorFn) (*GetVesselIdInspectionsResponse, error)

	// GetVesselIdInspectionsDetailIdWithResponse request
	GetVesselIdInspectionsDetailIdWithResponse(ctx context.Context, id string, detailId string, params *GetVesselIdInspectionsDetailIdParams, reqEditors ...RequestEditorFn) (*GetVesselIdInspectionsDetailIdResponse, error)

	// GetVesselIdOwnershipWithResponse request
	GetVesselIdOwnershipWithResponse(ctx context.Context, id string, params *GetVesselIdOwnershipParams, reqEditors ...RequestEditorFn) (*GetVesselIdOwnershipResponse, error)

	// GetVesselIdPositionWithResponse request
	GetVesselIdPositionWithResponse(ctx context.Context, id string, params *GetVesselIdPositionParams, reqEditors ...RequestEditorFn) (*GetVesselIdPositionResponse, error)

	// GetVesselsPositionsWithResponse request
	GetVesselsPositionsWithResponse(ctx context.Context, params *GetVesselsPositionsParams, reqEditors ...RequestEditorFn) (*GetVesselsPositionsResponse, error)
}

type GetEmissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselEmissionsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetEmissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationDgpsBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DGPSStationsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationDgpsBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationDgpsBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationDgpsRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DGPSStationsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationDgpsRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationDgpsRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationLightaidsBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LightAidsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationLightaidsBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationLightaidsBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationLightaidsRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LightAidsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationLightaidsRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationLightaidsRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationModuBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MODUsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationModuBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationModuBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationModuRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MODUsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationModuRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationModuRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationPortsBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationPortsBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationPortsBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationPortsRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationPortsRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationPortsRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationRadiobeaconsBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RadioBeaconsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationRadiobeaconsBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationRadiobeaconsBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationRadiobeaconsRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RadioBeaconsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationRadiobeaconsRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationRadiobeaconsRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationVesselsBoundingBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationVesselsBoundingBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationVesselsBoundingBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationVesselsRadiusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselsWithinLocationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetLocationVesselsRadiusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationVesselsRadiusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNavtexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NavtexMessagesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetNavtexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNavtexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPortUnlocodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPortUnlocodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPortUnlocodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsPortUnlocodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsPortUnlocodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsPortUnlocodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsPortsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsPortsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsPortsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsVesselIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsVesselIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsVesselIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsVesselIdLastResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsVesselIdLastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsVesselIdLastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPorteventsVesselsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortEventsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPorteventsVesselsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPorteventsVesselsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchDgpsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindDGPSStationsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchDgpsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchDgpsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchLightaidsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindLightAidsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchLightaidsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchLightaidsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchModusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindMODUsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchModusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchModusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchPortsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindPortsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchPortsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchPortsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchRadiobeaconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindRadioBeaconsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchRadiobeaconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchRadiobeaconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchVesselsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FindVesselsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchVesselsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchVesselsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdCasualtiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarineCasualtiesResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdCasualtiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdCasualtiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdClassificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClassificationResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdClassificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdClassificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdEmissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselEmissionsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdEmissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdEmissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdEtaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselETAResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdEtaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdEtaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdInspectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TypesInspectionsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdInspectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdInspectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdInspectionsDetailIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TypesInspectionDetailResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdInspectionsDetailIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdInspectionsDetailIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdOwnershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TypesOwnershipResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdOwnershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdOwnershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselIdPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselPositionResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON404      *NotFoundErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselIdPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselIdPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVesselsPositionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VesselPositionsResponse
	JSON400      *BadRequestErrorResponse
	JSON401      *AuthenticationErrorResponse
	JSON429      *RateLimitErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetVesselsPositionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVesselsPositionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetEmissionsWithResponse request returning *GetEmissionsResponse
func (c *ClientWithResponses) GetEmissionsWithResponse(ctx context.Context, params *GetEmissionsParams, reqEditors ...RequestEditorFn) (*GetEmissionsResponse, error) {
	rsp, err := c.GetEmissions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEmissionsResponse(rsp)
}

// GetLocationDgpsBoundingBoxWithResponse request returning *GetLocationDgpsBoundingBoxResponse
func (c *ClientWithResponses) GetLocationDgpsBoundingBoxWithResponse(ctx context.Context, params *GetLocationDgpsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationDgpsBoundingBoxResponse, error) {
	rsp, err := c.GetLocationDgpsBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationDgpsBoundingBoxResponse(rsp)
}

// GetLocationDgpsRadiusWithResponse request returning *GetLocationDgpsRadiusResponse
func (c *ClientWithResponses) GetLocationDgpsRadiusWithResponse(ctx context.Context, params *GetLocationDgpsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationDgpsRadiusResponse, error) {
	rsp, err := c.GetLocationDgpsRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationDgpsRadiusResponse(rsp)
}

// GetLocationLightaidsBoundingBoxWithResponse request returning *GetLocationLightaidsBoundingBoxResponse
func (c *ClientWithResponses) GetLocationLightaidsBoundingBoxWithResponse(ctx context.Context, params *GetLocationLightaidsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationLightaidsBoundingBoxResponse, error) {
	rsp, err := c.GetLocationLightaidsBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationLightaidsBoundingBoxResponse(rsp)
}

// GetLocationLightaidsRadiusWithResponse request returning *GetLocationLightaidsRadiusResponse
func (c *ClientWithResponses) GetLocationLightaidsRadiusWithResponse(ctx context.Context, params *GetLocationLightaidsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationLightaidsRadiusResponse, error) {
	rsp, err := c.GetLocationLightaidsRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationLightaidsRadiusResponse(rsp)
}

// GetLocationModuBoundingBoxWithResponse request returning *GetLocationModuBoundingBoxResponse
func (c *ClientWithResponses) GetLocationModuBoundingBoxWithResponse(ctx context.Context, params *GetLocationModuBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationModuBoundingBoxResponse, error) {
	rsp, err := c.GetLocationModuBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationModuBoundingBoxResponse(rsp)
}

// GetLocationModuRadiusWithResponse request returning *GetLocationModuRadiusResponse
func (c *ClientWithResponses) GetLocationModuRadiusWithResponse(ctx context.Context, params *GetLocationModuRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationModuRadiusResponse, error) {
	rsp, err := c.GetLocationModuRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationModuRadiusResponse(rsp)
}

// GetLocationPortsBoundingBoxWithResponse request returning *GetLocationPortsBoundingBoxResponse
func (c *ClientWithResponses) GetLocationPortsBoundingBoxWithResponse(ctx context.Context, params *GetLocationPortsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationPortsBoundingBoxResponse, error) {
	rsp, err := c.GetLocationPortsBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationPortsBoundingBoxResponse(rsp)
}

// GetLocationPortsRadiusWithResponse request returning *GetLocationPortsRadiusResponse
func (c *ClientWithResponses) GetLocationPortsRadiusWithResponse(ctx context.Context, params *GetLocationPortsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationPortsRadiusResponse, error) {
	rsp, err := c.GetLocationPortsRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationPortsRadiusResponse(rsp)
}

// GetLocationRadiobeaconsBoundingBoxWithResponse request returning *GetLocationRadiobeaconsBoundingBoxResponse
func (c *ClientWithResponses) GetLocationRadiobeaconsBoundingBoxWithResponse(ctx context.Context, params *GetLocationRadiobeaconsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationRadiobeaconsBoundingBoxResponse, error) {
	rsp, err := c.GetLocationRadiobeaconsBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationRadiobeaconsBoundingBoxResponse(rsp)
}

// GetLocationRadiobeaconsRadiusWithResponse request returning *GetLocationRadiobeaconsRadiusResponse
func (c *ClientWithResponses) GetLocationRadiobeaconsRadiusWithResponse(ctx context.Context, params *GetLocationRadiobeaconsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationRadiobeaconsRadiusResponse, error) {
	rsp, err := c.GetLocationRadiobeaconsRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationRadiobeaconsRadiusResponse(rsp)
}

// GetLocationVesselsBoundingBoxWithResponse request returning *GetLocationVesselsBoundingBoxResponse
func (c *ClientWithResponses) GetLocationVesselsBoundingBoxWithResponse(ctx context.Context, params *GetLocationVesselsBoundingBoxParams, reqEditors ...RequestEditorFn) (*GetLocationVesselsBoundingBoxResponse, error) {
	rsp, err := c.GetLocationVesselsBoundingBox(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationVesselsBoundingBoxResponse(rsp)
}

// GetLocationVesselsRadiusWithResponse request returning *GetLocationVesselsRadiusResponse
func (c *ClientWithResponses) GetLocationVesselsRadiusWithResponse(ctx context.Context, params *GetLocationVesselsRadiusParams, reqEditors ...RequestEditorFn) (*GetLocationVesselsRadiusResponse, error) {
	rsp, err := c.GetLocationVesselsRadius(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationVesselsRadiusResponse(rsp)
}

// GetNavtexWithResponse request returning *GetNavtexResponse
func (c *ClientWithResponses) GetNavtexWithResponse(ctx context.Context, params *GetNavtexParams, reqEditors ...RequestEditorFn) (*GetNavtexResponse, error) {
	rsp, err := c.GetNavtex(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNavtexResponse(rsp)
}

// GetPortUnlocodeWithResponse request returning *GetPortUnlocodeResponse
func (c *ClientWithResponses) GetPortUnlocodeWithResponse(ctx context.Context, unlocode string, reqEditors ...RequestEditorFn) (*GetPortUnlocodeResponse, error) {
	rsp, err := c.GetPortUnlocode(ctx, unlocode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPortUnlocodeResponse(rsp)
}

// GetPorteventsWithResponse request returning *GetPorteventsResponse
func (c *ClientWithResponses) GetPorteventsWithResponse(ctx context.Context, params *GetPorteventsParams, reqEditors ...RequestEditorFn) (*GetPorteventsResponse, error) {
	rsp, err := c.GetPortevents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsResponse(rsp)
}

// GetPorteventsPortUnlocodeWithResponse request returning *GetPorteventsPortUnlocodeResponse
func (c *ClientWithResponses) GetPorteventsPortUnlocodeWithResponse(ctx context.Context, unlocode string, params *GetPorteventsPortUnlocodeParams, reqEditors ...RequestEditorFn) (*GetPorteventsPortUnlocodeResponse, error) {
	rsp, err := c.GetPorteventsPortUnlocode(ctx, unlocode, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsPortUnlocodeResponse(rsp)
}

// GetPorteventsPortsWithResponse request returning *GetPorteventsPortsResponse
func (c *ClientWithResponses) GetPorteventsPortsWithResponse(ctx context.Context, params *GetPorteventsPortsParams, reqEditors ...RequestEditorFn) (*GetPorteventsPortsResponse, error) {
	rsp, err := c.GetPorteventsPorts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsPortsResponse(rsp)
}

// GetPorteventsVesselIdWithResponse request returning *GetPorteventsVesselIdResponse
func (c *ClientWithResponses) GetPorteventsVesselIdWithResponse(ctx context.Context, id string, params *GetPorteventsVesselIdParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselIdResponse, error) {
	rsp, err := c.GetPorteventsVesselId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsVesselIdResponse(rsp)
}

// GetPorteventsVesselIdLastWithResponse request returning *GetPorteventsVesselIdLastResponse
func (c *ClientWithResponses) GetPorteventsVesselIdLastWithResponse(ctx context.Context, id string, params *GetPorteventsVesselIdLastParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselIdLastResponse, error) {
	rsp, err := c.GetPorteventsVesselIdLast(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsVesselIdLastResponse(rsp)
}

// GetPorteventsVesselsWithResponse request returning *GetPorteventsVesselsResponse
func (c *ClientWithResponses) GetPorteventsVesselsWithResponse(ctx context.Context, params *GetPorteventsVesselsParams, reqEditors ...RequestEditorFn) (*GetPorteventsVesselsResponse, error) {
	rsp, err := c.GetPorteventsVessels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPorteventsVesselsResponse(rsp)
}

// GetSearchDgpsWithResponse request returning *GetSearchDgpsResponse
func (c *ClientWithResponses) GetSearchDgpsWithResponse(ctx context.Context, params *GetSearchDgpsParams, reqEditors ...RequestEditorFn) (*GetSearchDgpsResponse, error) {
	rsp, err := c.GetSearchDgps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchDgpsResponse(rsp)
}

// GetSearchLightaidsWithResponse request returning *GetSearchLightaidsResponse
func (c *ClientWithResponses) GetSearchLightaidsWithResponse(ctx context.Context, params *GetSearchLightaidsParams, reqEditors ...RequestEditorFn) (*GetSearchLightaidsResponse, error) {
	rsp, err := c.GetSearchLightaids(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchLightaidsResponse(rsp)
}

// GetSearchModusWithResponse request returning *GetSearchModusResponse
func (c *ClientWithResponses) GetSearchModusWithResponse(ctx context.Context, params *GetSearchModusParams, reqEditors ...RequestEditorFn) (*GetSearchModusResponse, error) {
	rsp, err := c.GetSearchModus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchModusResponse(rsp)
}

// GetSearchPortsWithResponse request returning *GetSearchPortsResponse
func (c *ClientWithResponses) GetSearchPortsWithResponse(ctx context.Context, params *GetSearchPortsParams, reqEditors ...RequestEditorFn) (*GetSearchPortsResponse, error) {
	rsp, err := c.GetSearchPorts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchPortsResponse(rsp)
}

// GetSearchRadiobeaconsWithResponse request returning *GetSearchRadiobeaconsResponse
func (c *ClientWithResponses) GetSearchRadiobeaconsWithResponse(ctx context.Context, params *GetSearchRadiobeaconsParams, reqEditors ...RequestEditorFn) (*GetSearchRadiobeaconsResponse, error) {
	rsp, err := c.GetSearchRadiobeacons(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchRadiobeaconsResponse(rsp)
}

// GetSearchVesselsWithResponse request returning *GetSearchVesselsResponse
func (c *ClientWithResponses) GetSearchVesselsWithResponse(ctx context.Context, params *GetSearchVesselsParams, reqEditors ...RequestEditorFn) (*GetSearchVesselsResponse, error) {
	rsp, err := c.GetSearchVessels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchVesselsResponse(rsp)
}

// GetVesselIdWithResponse request returning *GetVesselIdResponse
func (c *ClientWithResponses) GetVesselIdWithResponse(ctx context.Context, id string, params *GetVesselIdParams, reqEditors ...RequestEditorFn) (*GetVesselIdResponse, error) {
	rsp, err := c.GetVesselId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdResponse(rsp)
}

// GetVesselIdCasualtiesWithResponse request returning *GetVesselIdCasualtiesResponse
func (c *ClientWithResponses) GetVesselIdCasualtiesWithResponse(ctx context.Context, id string, params *GetVesselIdCasualtiesParams, reqEditors ...RequestEditorFn) (*GetVesselIdCasualtiesResponse, error) {
	rsp, err := c.GetVesselIdCasualties(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdCasualtiesResponse(rsp)
}

// GetVesselIdClassificationWithResponse request returning *GetVesselIdClassificationResponse
func (c *ClientWithResponses) GetVesselIdClassificationWithResponse(ctx context.Context, id string, params *GetVesselIdClassificationParams, reqEditors ...RequestEditorFn) (*GetVesselIdClassificationResponse, error) {
	rsp, err := c.GetVesselIdClassification(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdClassificationResponse(rsp)
}

// GetVesselIdEmissionsWithResponse request returning *GetVesselIdEmissionsResponse
func (c *ClientWithResponses) GetVesselIdEmissionsWithResponse(ctx context.Context, id string, params *GetVesselIdEmissionsParams, reqEditors ...RequestEditorFn) (*GetVesselIdEmissionsResponse, error) {
	rsp, err := c.GetVesselIdEmissions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdEmissionsResponse(rsp)
}

// GetVesselIdEtaWithResponse request returning *GetVesselIdEtaResponse
func (c *ClientWithResponses) GetVesselIdEtaWithResponse(ctx context.Context, id string, params *GetVesselIdEtaParams, reqEditors ...RequestEditorFn) (*GetVesselIdEtaResponse, error) {
	rsp, err := c.GetVesselIdEta(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdEtaResponse(rsp)
}

// GetVesselIdInspectionsWithResponse request returning *GetVesselIdInspectionsResponse
func (c *ClientWithResponses) GetVesselIdInspectionsWithResponse(ctx context.Context, id string, params *GetVesselIdInspectionsParams, reqEditors ...RequestEditorFn) (*GetVesselIdInspectionsResponse, error) {
	rsp, err := c.GetVesselIdInspections(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdInspectionsResponse(rsp)
}

// GetVesselIdInspectionsDetailIdWithResponse request returning *GetVesselIdInspectionsDetailIdResponse
func (c *ClientWithResponses) GetVesselIdInspectionsDetailIdWithResponse(ctx context.Context, id string, detailId string, params *GetVesselIdInspectionsDetailIdParams, reqEditors ...RequestEditorFn) (*GetVesselIdInspectionsDetailIdResponse, error) {
	rsp, err := c.GetVesselIdInspectionsDetailId(ctx, id, detailId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdInspectionsDetailIdResponse(rsp)
}

// GetVesselIdOwnershipWithResponse request returning *GetVesselIdOwnershipResponse
func (c *ClientWithResponses) GetVesselIdOwnershipWithResponse(ctx context.Context, id string, params *GetVesselIdOwnershipParams, reqEditors ...RequestEditorFn) (*GetVesselIdOwnershipResponse, error) {
	rsp, err := c.GetVesselIdOwnership(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdOwnershipResponse(rsp)
}

// GetVesselIdPositionWithResponse request returning *GetVesselIdPositionResponse
func (c *ClientWithResponses) GetVesselIdPositionWithResponse(ctx context.Context, id string, params *GetVesselIdPositionParams, reqEditors ...RequestEditorFn) (*GetVesselIdPositionResponse, error) {
	rsp, err := c.GetVesselIdPosition(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselIdPositionResponse(rsp)
}

// GetVesselsPositionsWithResponse request returning *GetVesselsPositionsResponse
func (c *ClientWithResponses) GetVesselsPositionsWithResponse(ctx context.Context, params *GetVesselsPositionsParams, reqEditors ...RequestEditorFn) (*GetVesselsPositionsResponse, error) {
	rsp, err := c.GetVesselsPositions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVesselsPositionsResponse(rsp)
}

// ParseGetEmissionsResponse parses an HTTP response from a GetEmissionsWithResponse call
func ParseGetEmissionsResponse(rsp *http.Response) (*GetEmissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEmissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselEmissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationDgpsBoundingBoxResponse parses an HTTP response from a GetLocationDgpsBoundingBoxWithResponse call
func ParseGetLocationDgpsBoundingBoxResponse(rsp *http.Response) (*GetLocationDgpsBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationDgpsBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DGPSStationsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationDgpsRadiusResponse parses an HTTP response from a GetLocationDgpsRadiusWithResponse call
func ParseGetLocationDgpsRadiusResponse(rsp *http.Response) (*GetLocationDgpsRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationDgpsRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DGPSStationsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationLightaidsBoundingBoxResponse parses an HTTP response from a GetLocationLightaidsBoundingBoxWithResponse call
func ParseGetLocationLightaidsBoundingBoxResponse(rsp *http.Response) (*GetLocationLightaidsBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationLightaidsBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LightAidsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationLightaidsRadiusResponse parses an HTTP response from a GetLocationLightaidsRadiusWithResponse call
func ParseGetLocationLightaidsRadiusResponse(rsp *http.Response) (*GetLocationLightaidsRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationLightaidsRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LightAidsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationModuBoundingBoxResponse parses an HTTP response from a GetLocationModuBoundingBoxWithResponse call
func ParseGetLocationModuBoundingBoxResponse(rsp *http.Response) (*GetLocationModuBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationModuBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MODUsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationModuRadiusResponse parses an HTTP response from a GetLocationModuRadiusWithResponse call
func ParseGetLocationModuRadiusResponse(rsp *http.Response) (*GetLocationModuRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationModuRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MODUsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationPortsBoundingBoxResponse parses an HTTP response from a GetLocationPortsBoundingBoxWithResponse call
func ParseGetLocationPortsBoundingBoxResponse(rsp *http.Response) (*GetLocationPortsBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationPortsBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationPortsRadiusResponse parses an HTTP response from a GetLocationPortsRadiusWithResponse call
func ParseGetLocationPortsRadiusResponse(rsp *http.Response) (*GetLocationPortsRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationPortsRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationRadiobeaconsBoundingBoxResponse parses an HTTP response from a GetLocationRadiobeaconsBoundingBoxWithResponse call
func ParseGetLocationRadiobeaconsBoundingBoxResponse(rsp *http.Response) (*GetLocationRadiobeaconsBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationRadiobeaconsBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RadioBeaconsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationRadiobeaconsRadiusResponse parses an HTTP response from a GetLocationRadiobeaconsRadiusWithResponse call
func ParseGetLocationRadiobeaconsRadiusResponse(rsp *http.Response) (*GetLocationRadiobeaconsRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationRadiobeaconsRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RadioBeaconsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationVesselsBoundingBoxResponse parses an HTTP response from a GetLocationVesselsBoundingBoxWithResponse call
func ParseGetLocationVesselsBoundingBoxResponse(rsp *http.Response) (*GetLocationVesselsBoundingBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationVesselsBoundingBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLocationVesselsRadiusResponse parses an HTTP response from a GetLocationVesselsRadiusWithResponse call
func ParseGetLocationVesselsRadiusResponse(rsp *http.Response) (*GetLocationVesselsRadiusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationVesselsRadiusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselsWithinLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNavtexResponse parses an HTTP response from a GetNavtexWithResponse call
func ParseGetNavtexResponse(rsp *http.Response) (*GetNavtexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNavtexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NavtexMessagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPortUnlocodeResponse parses an HTTP response from a GetPortUnlocodeWithResponse call
func ParseGetPortUnlocodeResponse(rsp *http.Response) (*GetPortUnlocodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPortUnlocodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsResponse parses an HTTP response from a GetPorteventsWithResponse call
func ParseGetPorteventsResponse(rsp *http.Response) (*GetPorteventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsPortUnlocodeResponse parses an HTTP response from a GetPorteventsPortUnlocodeWithResponse call
func ParseGetPorteventsPortUnlocodeResponse(rsp *http.Response) (*GetPorteventsPortUnlocodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsPortUnlocodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsPortsResponse parses an HTTP response from a GetPorteventsPortsWithResponse call
func ParseGetPorteventsPortsResponse(rsp *http.Response) (*GetPorteventsPortsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsPortsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsVesselIdResponse parses an HTTP response from a GetPorteventsVesselIdWithResponse call
func ParseGetPorteventsVesselIdResponse(rsp *http.Response) (*GetPorteventsVesselIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsVesselIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsVesselIdLastResponse parses an HTTP response from a GetPorteventsVesselIdLastWithResponse call
func ParseGetPorteventsVesselIdLastResponse(rsp *http.Response) (*GetPorteventsVesselIdLastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsVesselIdLastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPorteventsVesselsResponse parses an HTTP response from a GetPorteventsVesselsWithResponse call
func ParseGetPorteventsVesselsResponse(rsp *http.Response) (*GetPorteventsVesselsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPorteventsVesselsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchDgpsResponse parses an HTTP response from a GetSearchDgpsWithResponse call
func ParseGetSearchDgpsResponse(rsp *http.Response) (*GetSearchDgpsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchDgpsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindDGPSStationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchLightaidsResponse parses an HTTP response from a GetSearchLightaidsWithResponse call
func ParseGetSearchLightaidsResponse(rsp *http.Response) (*GetSearchLightaidsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchLightaidsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindLightAidsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchModusResponse parses an HTTP response from a GetSearchModusWithResponse call
func ParseGetSearchModusResponse(rsp *http.Response) (*GetSearchModusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchModusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindMODUsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchPortsResponse parses an HTTP response from a GetSearchPortsWithResponse call
func ParseGetSearchPortsResponse(rsp *http.Response) (*GetSearchPortsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchPortsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindPortsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchRadiobeaconsResponse parses an HTTP response from a GetSearchRadiobeaconsWithResponse call
func ParseGetSearchRadiobeaconsResponse(rsp *http.Response) (*GetSearchRadiobeaconsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchRadiobeaconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindRadioBeaconsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchVesselsResponse parses an HTTP response from a GetSearchVesselsWithResponse call
func ParseGetSearchVesselsResponse(rsp *http.Response) (*GetSearchVesselsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchVesselsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FindVesselsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdResponse parses an HTTP response from a GetVesselIdWithResponse call
func ParseGetVesselIdResponse(rsp *http.Response) (*GetVesselIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdCasualtiesResponse parses an HTTP response from a GetVesselIdCasualtiesWithResponse call
func ParseGetVesselIdCasualtiesResponse(rsp *http.Response) (*GetVesselIdCasualtiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdCasualtiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarineCasualtiesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdClassificationResponse parses an HTTP response from a GetVesselIdClassificationWithResponse call
func ParseGetVesselIdClassificationResponse(rsp *http.Response) (*GetVesselIdClassificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdClassificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClassificationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdEmissionsResponse parses an HTTP response from a GetVesselIdEmissionsWithResponse call
func ParseGetVesselIdEmissionsResponse(rsp *http.Response) (*GetVesselIdEmissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdEmissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselEmissionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdEtaResponse parses an HTTP response from a GetVesselIdEtaWithResponse call
func ParseGetVesselIdEtaResponse(rsp *http.Response) (*GetVesselIdEtaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdEtaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselETAResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdInspectionsResponse parses an HTTP response from a GetVesselIdInspectionsWithResponse call
func ParseGetVesselIdInspectionsResponse(rsp *http.Response) (*GetVesselIdInspectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdInspectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TypesInspectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdInspectionsDetailIdResponse parses an HTTP response from a GetVesselIdInspectionsDetailIdWithResponse call
func ParseGetVesselIdInspectionsDetailIdResponse(rsp *http.Response) (*GetVesselIdInspectionsDetailIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdInspectionsDetailIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TypesInspectionDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdOwnershipResponse parses an HTTP response from a GetVesselIdOwnershipWithResponse call
func ParseGetVesselIdOwnershipResponse(rsp *http.Response) (*GetVesselIdOwnershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdOwnershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TypesOwnershipResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselIdPositionResponse parses an HTTP response from a GetVesselIdPositionWithResponse call
func ParseGetVesselIdPositionResponse(rsp *http.Response) (*GetVesselIdPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselIdPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselPositionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetVesselsPositionsResponse parses an HTTP response from a GetVesselsPositionsWithResponse call
func ParseGetVesselsPositionsResponse(rsp *http.Response) (*GetVesselsPositionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVesselsPositionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VesselPositionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthenticationErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest RateLimitErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
